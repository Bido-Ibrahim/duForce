import {
  Container,
  Point,
  Rectangle
} from "./chunk-W5OK4VCJ.js";
import "./chunk-5WWUZCGV.js";

// node_modules/@pixi/constants/dist/esm/constants.mjs
var ENV;
(function(ENV2) {
  ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
  ENV2[ENV2["WEBGL"] = 1] = "WEBGL";
  ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";
})(ENV || (ENV = {}));
var RENDERER_TYPE;
(function(RENDERER_TYPE2) {
  RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";
  RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";
  RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";
})(RENDERER_TYPE || (RENDERER_TYPE = {}));
var BUFFER_BITS;
(function(BUFFER_BITS2) {
  BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";
  BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";
  BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";
})(BUFFER_BITS || (BUFFER_BITS = {}));
var BLEND_MODES;
(function(BLEND_MODES2) {
  BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";
  BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";
  BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";
  BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";
  BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";
  BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";
  BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";
  BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";
  BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";
  BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";
  BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
  BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";
  BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";
  BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";
  BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";
  BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";
  BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";
  BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";
  BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";
  BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";
  BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";
  BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";
  BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";
  BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";
  BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";
  BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";
  BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";
  BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";
  BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";
  BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";
  BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";
  BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";
})(BLEND_MODES || (BLEND_MODES = {}));
var DRAW_MODES;
(function(DRAW_MODES2) {
  DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";
  DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";
  DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";
  DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
})(DRAW_MODES || (DRAW_MODES = {}));
var FORMATS;
(function(FORMATS2) {
  FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";
  FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";
  FORMATS2[FORMATS2["RG"] = 33319] = "RG";
  FORMATS2[FORMATS2["RED"] = 6403] = "RED";
  FORMATS2[FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  FORMATS2[FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  FORMATS2[FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
  FORMATS2[FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
  FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";
  FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
  FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
})(FORMATS || (FORMATS = {}));
var TARGETS;
(function(TARGETS2) {
  TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS || (TARGETS = {}));
var TYPES;
(function(TYPES2) {
  TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  TYPES2[TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  TYPES2[TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
  TYPES2[TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
  TYPES2[TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
  TYPES2[TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
  TYPES2[TYPES2["BYTE"] = 5120] = "BYTE";
  TYPES2[TYPES2["SHORT"] = 5122] = "SHORT";
  TYPES2[TYPES2["INT"] = 5124] = "INT";
  TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";
  TYPES2[TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
  TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
})(TYPES || (TYPES = {}));
var SAMPLER_TYPES;
(function(SAMPLER_TYPES2) {
  SAMPLER_TYPES2[SAMPLER_TYPES2["FLOAT"] = 0] = "FLOAT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["INT"] = 1] = "INT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["UINT"] = 2] = "UINT";
})(SAMPLER_TYPES || (SAMPLER_TYPES = {}));
var SCALE_MODES;
(function(SCALE_MODES2) {
  SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";
  SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";
})(SCALE_MODES || (SCALE_MODES = {}));
var WRAP_MODES;
(function(WRAP_MODES2) {
  WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
  WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
  WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES || (WRAP_MODES = {}));
var MIPMAP_MODES;
(function(MIPMAP_MODES2) {
  MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";
  MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";
  MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";
  MIPMAP_MODES2[MIPMAP_MODES2["ON_MANUAL"] = 3] = "ON_MANUAL";
})(MIPMAP_MODES || (MIPMAP_MODES = {}));
var ALPHA_MODES;
(function(ALPHA_MODES2) {
  ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
  ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
  ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
  ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES || (ALPHA_MODES = {}));
var CLEAR_MODES;
(function(CLEAR_MODES2) {
  CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";
  CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";
  CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";
  CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";
  CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";
  CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";
})(CLEAR_MODES || (CLEAR_MODES = {}));
var GC_MODES;
(function(GC_MODES2) {
  GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";
  GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";
})(GC_MODES || (GC_MODES = {}));
var PRECISION;
(function(PRECISION2) {
  PRECISION2["LOW"] = "lowp";
  PRECISION2["MEDIUM"] = "mediump";
  PRECISION2["HIGH"] = "highp";
})(PRECISION || (PRECISION = {}));
var MASK_TYPES;
(function(MASK_TYPES2) {
  MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";
  MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";
  MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";
  MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";
  MASK_TYPES2[MASK_TYPES2["COLOR"] = 4] = "COLOR";
})(MASK_TYPES || (MASK_TYPES = {}));
var COLOR_MASK_BITS;
(function(COLOR_MASK_BITS2) {
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["RED"] = 1] = "RED";
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["GREEN"] = 2] = "GREEN";
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["BLUE"] = 4] = "BLUE";
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["ALPHA"] = 8] = "ALPHA";
})(COLOR_MASK_BITS || (COLOR_MASK_BITS = {}));
var MSAA_QUALITY;
(function(MSAA_QUALITY2) {
  MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
  MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
  MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
  MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
})(MSAA_QUALITY || (MSAA_QUALITY = {}));
var BUFFER_TYPE;
(function(BUFFER_TYPE2) {
  BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE || (BUFFER_TYPE = {}));

// node_modules/@pixi/settings/dist/esm/settings.mjs
var BrowserAdapter = {
  /**
   * Creates a canvas element of the given size.
   * This canvas is created using the browser's native canvas element.
   * @param width - width of the canvas
   * @param height - height of the canvas
   */
  createCanvas: function(width, height) {
    var canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    return canvas;
  },
  getWebGLRenderingContext: function() {
    return WebGLRenderingContext;
  },
  getNavigator: function() {
    return navigator;
  },
  getBaseUrl: function() {
    var _a;
    return (_a = document.baseURI) !== null && _a !== void 0 ? _a : window.location.href;
  },
  fetch: function(url, options) {
    return fetch(url, options);
  }
};
var appleIphone = /iPhone/i;
var appleIpod = /iPod/i;
var appleTablet = /iPad/i;
var appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
var androidPhone = /\bAndroid(?:.+)Mobile\b/i;
var androidTablet = /Android/i;
var amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
var amazonTablet = /Silk/i;
var windowsPhone = /Windows Phone/i;
var windowsTablet = /\bWindows(?:.+)ARM\b/i;
var otherBlackBerry = /BlackBerry/i;
var otherBlackBerry10 = /BB10/i;
var otherOpera = /Opera Mini/i;
var otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
var otherFirefox = /Mobile(?:.+)Firefox\b/i;
var isAppleTabletOnIos13 = function(navigator2) {
  return typeof navigator2 !== "undefined" && navigator2.platform === "MacIntel" && typeof navigator2.maxTouchPoints === "number" && navigator2.maxTouchPoints > 1 && typeof MSStream === "undefined";
};
function createMatch(userAgent) {
  return function(regex) {
    return regex.test(userAgent);
  };
}
function isMobile$1(param) {
  var nav = {
    userAgent: "",
    platform: "",
    maxTouchPoints: 0
  };
  if (!param && typeof navigator !== "undefined") {
    nav = {
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      maxTouchPoints: navigator.maxTouchPoints || 0
    };
  } else if (typeof param === "string") {
    nav.userAgent = param;
  } else if (param && param.userAgent) {
    nav = {
      userAgent: param.userAgent,
      platform: param.platform,
      maxTouchPoints: param.maxTouchPoints || 0
    };
  }
  var userAgent = nav.userAgent;
  var tmp = userAgent.split("[FBAN");
  if (typeof tmp[1] !== "undefined") {
    userAgent = tmp[0];
  }
  tmp = userAgent.split("Twitter");
  if (typeof tmp[1] !== "undefined") {
    userAgent = tmp[0];
  }
  var match = createMatch(userAgent);
  var result = {
    apple: {
      phone: match(appleIphone) && !match(windowsPhone),
      ipod: match(appleIpod),
      tablet: !match(appleIphone) && (match(appleTablet) || isAppleTabletOnIos13(nav)) && !match(windowsPhone),
      universal: match(appleUniversal),
      device: (match(appleIphone) || match(appleIpod) || match(appleTablet) || match(appleUniversal) || isAppleTabletOnIos13(nav)) && !match(windowsPhone)
    },
    amazon: {
      phone: match(amazonPhone),
      tablet: !match(amazonPhone) && match(amazonTablet),
      device: match(amazonPhone) || match(amazonTablet)
    },
    android: {
      phone: !match(windowsPhone) && match(amazonPhone) || !match(windowsPhone) && match(androidPhone),
      tablet: !match(windowsPhone) && !match(amazonPhone) && !match(androidPhone) && (match(amazonTablet) || match(androidTablet)),
      device: !match(windowsPhone) && (match(amazonPhone) || match(amazonTablet) || match(androidPhone) || match(androidTablet)) || match(/\bokhttp\b/i)
    },
    windows: {
      phone: match(windowsPhone),
      tablet: match(windowsTablet),
      device: match(windowsPhone) || match(windowsTablet)
    },
    other: {
      blackberry: match(otherBlackBerry),
      blackberry10: match(otherBlackBerry10),
      opera: match(otherOpera),
      firefox: match(otherFirefox),
      chrome: match(otherChrome),
      device: match(otherBlackBerry) || match(otherBlackBerry10) || match(otherOpera) || match(otherFirefox) || match(otherChrome)
    },
    any: false,
    phone: false,
    tablet: false
  };
  result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;
  result.phone = result.apple.phone || result.android.phone || result.windows.phone;
  result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;
  return result;
}
var isMobile = isMobile$1(globalThis.navigator);
function canUploadSameBuffer() {
  return !isMobile.apple.device;
}
function maxRecommendedTextures(max) {
  var allowMax = true;
  if (isMobile.tablet || isMobile.phone) {
    if (isMobile.apple.device) {
      var match = navigator.userAgent.match(/OS (\d+)_(\d+)?/);
      if (match) {
        var majorVersion = parseInt(match[1], 10);
        if (majorVersion < 11) {
          allowMax = false;
        }
      }
    }
    if (isMobile.android.device) {
      var match = navigator.userAgent.match(/Android\s([0-9.]*)/);
      if (match) {
        var majorVersion = parseInt(match[1], 10);
        if (majorVersion < 7) {
          allowMax = false;
        }
      }
    }
  }
  return allowMax ? max : 4;
}
var settings = {
  /**
   * This adapter is used to call methods that are platform dependent.
   * For example `document.createElement` only runs on the web but fails in node environments.
   * This allows us to support more platforms by abstracting away specific implementations per platform.
   *
   * By default the adapter is set to work in the browser. However you can create your own
   * by implementing the `IAdapter` interface. See `IAdapter` for more information.
   * @name ADAPTER
   * @memberof PIXI.settings
   * @type {PIXI.IAdapter}
   * @default PIXI.BrowserAdapter
   */
  ADAPTER: BrowserAdapter,
  /**
   * If set to true WebGL will attempt make textures mimpaped by default.
   * Mipmapping will only succeed if the base texture uploaded has power of two dimensions.
   * @static
   * @name MIPMAP_TEXTURES
   * @memberof PIXI.settings
   * @type {PIXI.MIPMAP_MODES}
   * @default PIXI.MIPMAP_MODES.POW2
   */
  MIPMAP_TEXTURES: MIPMAP_MODES.POW2,
  /**
   * Default anisotropic filtering level of textures.
   * Usually from 0 to 16
   * @static
   * @name ANISOTROPIC_LEVEL
   * @memberof PIXI.settings
   * @type {number}
   * @default 0
   */
  ANISOTROPIC_LEVEL: 0,
  /**
   * Default resolution / device pixel ratio of the renderer.
   * @static
   * @name RESOLUTION
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  RESOLUTION: 1,
  /**
   * Default filter resolution.
   * @static
   * @name FILTER_RESOLUTION
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  FILTER_RESOLUTION: 1,
  /**
   * Default filter samples.
   * @static
   * @name FILTER_MULTISAMPLE
   * @memberof PIXI.settings
   * @type {PIXI.MSAA_QUALITY}
   * @default PIXI.MSAA_QUALITY.NONE
   */
  FILTER_MULTISAMPLE: MSAA_QUALITY.NONE,
  /**
   * The maximum textures that this device supports.
   * @static
   * @name SPRITE_MAX_TEXTURES
   * @memberof PIXI.settings
   * @type {number}
   * @default 32
   */
  SPRITE_MAX_TEXTURES: maxRecommendedTextures(32),
  // TODO: maybe change to SPRITE.BATCH_SIZE: 2000
  // TODO: maybe add PARTICLE.BATCH_SIZE: 15000
  /**
   * The default sprite batch size.
   *
   * The default aims to balance desktop and mobile devices.
   * @static
   * @name SPRITE_BATCH_SIZE
   * @memberof PIXI.settings
   * @type {number}
   * @default 4096
   */
  SPRITE_BATCH_SIZE: 4096,
  /**
   * The default render options if none are supplied to {@link PIXI.Renderer}
   * or {@link PIXI.CanvasRenderer}.
   * @static
   * @name RENDER_OPTIONS
   * @memberof PIXI.settings
   * @type {object}
   * @property {boolean} [antialias=false] - {@link PIXI.IRendererOptions.antialias}
   * @property {boolean} [autoDensity=false] - {@link PIXI.IRendererOptions.autoDensity}
   * @property {number} [backgroundAlpha=1] - {@link PIXI.IRendererOptions.backgroundAlpha}
   * @property {number} [backgroundColor=0x000000] - {@link PIXI.IRendererOptions.backgroundColor}
   * @property {boolean} [clearBeforeRender=true] - {@link PIXI.IRendererOptions.clearBeforeRender}
   * @property {number} [height=600] - {@link PIXI.IRendererOptions.height}
   * @property {boolean} [preserveDrawingBuffer=false] - {@link PIXI.IRendererOptions.preserveDrawingBuffer}
   * @property {boolean|'notMultiplied'} [useContextAlpha=true] - {@link PIXI.IRendererOptions.useContextAlpha}
   * @property {HTMLCanvasElement} [view=null] - {@link PIXI.IRendererOptions.view}
   * @property {number} [width=800] - {@link PIXI.IRendererOptions.width}
   */
  RENDER_OPTIONS: {
    view: null,
    width: 800,
    height: 600,
    autoDensity: false,
    backgroundColor: 0,
    backgroundAlpha: 1,
    useContextAlpha: true,
    clearBeforeRender: true,
    antialias: false,
    preserveDrawingBuffer: false
  },
  /**
   * Default Garbage Collection mode.
   * @static
   * @name GC_MODE
   * @memberof PIXI.settings
   * @type {PIXI.GC_MODES}
   * @default PIXI.GC_MODES.AUTO
   */
  GC_MODE: GC_MODES.AUTO,
  /**
   * Default Garbage Collection max idle.
   * @static
   * @name GC_MAX_IDLE
   * @memberof PIXI.settings
   * @type {number}
   * @default 3600
   */
  GC_MAX_IDLE: 60 * 60,
  /**
   * Default Garbage Collection maximum check count.
   * @static
   * @name GC_MAX_CHECK_COUNT
   * @memberof PIXI.settings
   * @type {number}
   * @default 600
   */
  GC_MAX_CHECK_COUNT: 60 * 10,
  /**
   * Default wrap modes that are supported by pixi.
   * @static
   * @name WRAP_MODE
   * @memberof PIXI.settings
   * @type {PIXI.WRAP_MODES}
   * @default PIXI.WRAP_MODES.CLAMP
   */
  WRAP_MODE: WRAP_MODES.CLAMP,
  /**
   * Default scale mode for textures.
   * @static
   * @name SCALE_MODE
   * @memberof PIXI.settings
   * @type {PIXI.SCALE_MODES}
   * @default PIXI.SCALE_MODES.LINEAR
   */
  SCALE_MODE: SCALE_MODES.LINEAR,
  /**
   * Default specify float precision in vertex shader.
   * @static
   * @name PRECISION_VERTEX
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @default PIXI.PRECISION.HIGH
   */
  PRECISION_VERTEX: PRECISION.HIGH,
  /**
   * Default specify float precision in fragment shader.
   * iOS is best set at highp due to https://github.com/pixijs/pixi.js/issues/3742
   * @static
   * @name PRECISION_FRAGMENT
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @default PIXI.PRECISION.MEDIUM
   */
  PRECISION_FRAGMENT: isMobile.apple.device ? PRECISION.HIGH : PRECISION.MEDIUM,
  /**
   * Can we upload the same buffer in a single frame?
   * @static
   * @name CAN_UPLOAD_SAME_BUFFER
   * @memberof PIXI.settings
   * @type {boolean}
   */
  CAN_UPLOAD_SAME_BUFFER: canUploadSameBuffer(),
  /**
   * Enables bitmap creation before image load. This feature is experimental.
   * @static
   * @name CREATE_IMAGE_BITMAP
   * @memberof PIXI.settings
   * @type {boolean}
   * @default false
   */
  CREATE_IMAGE_BITMAP: false,
  /**
   * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
   * Advantages can include sharper image quality (like text) and faster rendering on canvas.
   * The main disadvantage is movement of objects may appear less smooth.
   * @static
   * @constant
   * @memberof PIXI.settings
   * @type {boolean}
   * @default false
   */
  ROUND_PIXELS: false
};

// node_modules/@pixi/extensions/dist/esm/extensions.mjs
var ExtensionType;
(function(ExtensionType2) {
  ExtensionType2["Application"] = "application";
  ExtensionType2["RendererPlugin"] = "renderer-webgl-plugin";
  ExtensionType2["CanvasRendererPlugin"] = "renderer-canvas-plugin";
  ExtensionType2["Loader"] = "loader";
  ExtensionType2["LoadParser"] = "load-parser";
  ExtensionType2["ResolveParser"] = "resolve-parser";
  ExtensionType2["CacheParser"] = "cache-parser";
  ExtensionType2["DetectionParser"] = "detection-parser";
})(ExtensionType || (ExtensionType = {}));

// node_modules/@pixi/ticker/dist/esm/ticker.mjs
settings.TARGET_FPMS = 0.06;
var UPDATE_PRIORITY;
(function(UPDATE_PRIORITY2) {
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";
})(UPDATE_PRIORITY || (UPDATE_PRIORITY = {}));
var TickerListener = (
  /** @class */
  function() {
    function TickerListener2(fn, context, priority, once) {
      if (context === void 0) {
        context = null;
      }
      if (priority === void 0) {
        priority = 0;
      }
      if (once === void 0) {
        once = false;
      }
      this.next = null;
      this.previous = null;
      this._destroyed = false;
      this.fn = fn;
      this.context = context;
      this.priority = priority;
      this.once = once;
    }
    TickerListener2.prototype.match = function(fn, context) {
      if (context === void 0) {
        context = null;
      }
      return this.fn === fn && this.context === context;
    };
    TickerListener2.prototype.emit = function(deltaTime) {
      if (this.fn) {
        if (this.context) {
          this.fn.call(this.context, deltaTime);
        } else {
          this.fn(deltaTime);
        }
      }
      var redirect = this.next;
      if (this.once) {
        this.destroy(true);
      }
      if (this._destroyed) {
        this.next = null;
      }
      return redirect;
    };
    TickerListener2.prototype.connect = function(previous) {
      this.previous = previous;
      if (previous.next) {
        previous.next.previous = this;
      }
      this.next = previous.next;
      previous.next = this;
    };
    TickerListener2.prototype.destroy = function(hard) {
      if (hard === void 0) {
        hard = false;
      }
      this._destroyed = true;
      this.fn = null;
      this.context = null;
      if (this.previous) {
        this.previous.next = this.next;
      }
      if (this.next) {
        this.next.previous = this.previous;
      }
      var redirect = this.next;
      this.next = hard ? null : redirect;
      this.previous = null;
      return redirect;
    };
    return TickerListener2;
  }()
);
var Ticker = (
  /** @class */
  function() {
    function Ticker2() {
      var _this = this;
      this.autoStart = false;
      this.deltaTime = 1;
      this.lastTime = -1;
      this.speed = 1;
      this.started = false;
      this._requestId = null;
      this._maxElapsedMS = 100;
      this._minElapsedMS = 0;
      this._protected = false;
      this._lastFrame = -1;
      this._head = new TickerListener(null, null, Infinity);
      this.deltaMS = 1 / settings.TARGET_FPMS;
      this.elapsedMS = 1 / settings.TARGET_FPMS;
      this._tick = function(time) {
        _this._requestId = null;
        if (_this.started) {
          _this.update(time);
          if (_this.started && _this._requestId === null && _this._head.next) {
            _this._requestId = requestAnimationFrame(_this._tick);
          }
        }
      };
    }
    Ticker2.prototype._requestIfNeeded = function() {
      if (this._requestId === null && this._head.next) {
        this.lastTime = performance.now();
        this._lastFrame = this.lastTime;
        this._requestId = requestAnimationFrame(this._tick);
      }
    };
    Ticker2.prototype._cancelIfNeeded = function() {
      if (this._requestId !== null) {
        cancelAnimationFrame(this._requestId);
        this._requestId = null;
      }
    };
    Ticker2.prototype._startIfPossible = function() {
      if (this.started) {
        this._requestIfNeeded();
      } else if (this.autoStart) {
        this.start();
      }
    };
    Ticker2.prototype.add = function(fn, context, priority) {
      if (priority === void 0) {
        priority = UPDATE_PRIORITY.NORMAL;
      }
      return this._addListener(new TickerListener(fn, context, priority));
    };
    Ticker2.prototype.addOnce = function(fn, context, priority) {
      if (priority === void 0) {
        priority = UPDATE_PRIORITY.NORMAL;
      }
      return this._addListener(new TickerListener(fn, context, priority, true));
    };
    Ticker2.prototype._addListener = function(listener) {
      var current = this._head.next;
      var previous = this._head;
      if (!current) {
        listener.connect(previous);
      } else {
        while (current) {
          if (listener.priority > current.priority) {
            listener.connect(previous);
            break;
          }
          previous = current;
          current = current.next;
        }
        if (!listener.previous) {
          listener.connect(previous);
        }
      }
      this._startIfPossible();
      return this;
    };
    Ticker2.prototype.remove = function(fn, context) {
      var listener = this._head.next;
      while (listener) {
        if (listener.match(fn, context)) {
          listener = listener.destroy();
        } else {
          listener = listener.next;
        }
      }
      if (!this._head.next) {
        this._cancelIfNeeded();
      }
      return this;
    };
    Object.defineProperty(Ticker2.prototype, "count", {
      /**
       * The number of listeners on this ticker, calculated by walking through linked list
       * @readonly
       * @member {number}
       */
      get: function() {
        if (!this._head) {
          return 0;
        }
        var count = 0;
        var current = this._head;
        while (current = current.next) {
          count++;
        }
        return count;
      },
      enumerable: false,
      configurable: true
    });
    Ticker2.prototype.start = function() {
      if (!this.started) {
        this.started = true;
        this._requestIfNeeded();
      }
    };
    Ticker2.prototype.stop = function() {
      if (this.started) {
        this.started = false;
        this._cancelIfNeeded();
      }
    };
    Ticker2.prototype.destroy = function() {
      if (!this._protected) {
        this.stop();
        var listener = this._head.next;
        while (listener) {
          listener = listener.destroy(true);
        }
        this._head.destroy();
        this._head = null;
      }
    };
    Ticker2.prototype.update = function(currentTime) {
      if (currentTime === void 0) {
        currentTime = performance.now();
      }
      var elapsedMS;
      if (currentTime > this.lastTime) {
        elapsedMS = this.elapsedMS = currentTime - this.lastTime;
        if (elapsedMS > this._maxElapsedMS) {
          elapsedMS = this._maxElapsedMS;
        }
        elapsedMS *= this.speed;
        if (this._minElapsedMS) {
          var delta = currentTime - this._lastFrame | 0;
          if (delta < this._minElapsedMS) {
            return;
          }
          this._lastFrame = currentTime - delta % this._minElapsedMS;
        }
        this.deltaMS = elapsedMS;
        this.deltaTime = this.deltaMS * settings.TARGET_FPMS;
        var head = this._head;
        var listener = head.next;
        while (listener) {
          listener = listener.emit(this.deltaTime);
        }
        if (!head.next) {
          this._cancelIfNeeded();
        }
      } else {
        this.deltaTime = this.deltaMS = this.elapsedMS = 0;
      }
      this.lastTime = currentTime;
    };
    Object.defineProperty(Ticker2.prototype, "FPS", {
      /**
       * The frames per second at which this ticker is running.
       * The default is approximately 60 in most modern browsers.
       * **Note:** This does not factor in the value of
       * {@link PIXI.Ticker#speed}, which is specific
       * to scaling {@link PIXI.Ticker#deltaTime}.
       * @member {number}
       * @readonly
       */
      get: function() {
        return 1e3 / this.elapsedMS;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Ticker2.prototype, "minFPS", {
      /**
       * Manages the maximum amount of milliseconds allowed to
       * elapse between invoking {@link PIXI.Ticker#update}.
       * This value is used to cap {@link PIXI.Ticker#deltaTime},
       * but does not effect the measured value of {@link PIXI.Ticker#FPS}.
       * When setting this property it is clamped to a value between
       * `0` and `PIXI.settings.TARGET_FPMS * 1000`.
       * @member {number}
       * @default 10
       */
      get: function() {
        return 1e3 / this._maxElapsedMS;
      },
      set: function(fps) {
        var minFPS = Math.min(this.maxFPS, fps);
        var minFPMS = Math.min(Math.max(0, minFPS) / 1e3, settings.TARGET_FPMS);
        this._maxElapsedMS = 1 / minFPMS;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Ticker2.prototype, "maxFPS", {
      /**
       * Manages the minimum amount of milliseconds required to
       * elapse between invoking {@link PIXI.Ticker#update}.
       * This will effect the measured value of {@link PIXI.Ticker#FPS}.
       * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
       * Otherwise it will be at least `minFPS`
       * @member {number}
       * @default 0
       */
      get: function() {
        if (this._minElapsedMS) {
          return Math.round(1e3 / this._minElapsedMS);
        }
        return 0;
      },
      set: function(fps) {
        if (fps === 0) {
          this._minElapsedMS = 0;
        } else {
          var maxFPS = Math.max(this.minFPS, fps);
          this._minElapsedMS = 1 / (maxFPS / 1e3);
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Ticker2, "shared", {
      /**
       * The shared ticker instance used by {@link PIXI.AnimatedSprite} and by
       * {@link PIXI.VideoResource} to update animation frames / video textures.
       *
       * It may also be used by {@link PIXI.Application} if created with the `sharedTicker` option property set to true.
       *
       * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
       * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
       * @example
       * let ticker = PIXI.Ticker.shared;
       * // Set this to prevent starting this ticker when listeners are added.
       * // By default this is true only for the PIXI.Ticker.shared instance.
       * ticker.autoStart = false;
       * // FYI, call this to ensure the ticker is stopped. It should be stopped
       * // if you have not attempted to render anything yet.
       * ticker.stop();
       * // Call this when you are ready for a running shared ticker.
       * ticker.start();
       * @example
       * // You may use the shared ticker to render...
       * let renderer = PIXI.autoDetectRenderer();
       * let stage = new PIXI.Container();
       * document.body.appendChild(renderer.view);
       * ticker.add(function (time) {
       *     renderer.render(stage);
       * });
       * @example
       * // Or you can just update it manually.
       * ticker.autoStart = false;
       * ticker.stop();
       * function animate(time) {
       *     ticker.update(time);
       *     renderer.render(stage);
       *     requestAnimationFrame(animate);
       * }
       * animate(performance.now());
       * @member {PIXI.Ticker}
       * @static
       */
      get: function() {
        if (!Ticker2._shared) {
          var shared = Ticker2._shared = new Ticker2();
          shared.autoStart = true;
          shared._protected = true;
        }
        return Ticker2._shared;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Ticker2, "system", {
      /**
       * The system ticker instance used by {@link PIXI.InteractionManager} and by
       * {@link PIXI.BasePrepare} for core timing functionality that shouldn't usually need to be paused,
       * unlike the `shared` ticker which drives visual animations and rendering which may want to be paused.
       *
       * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
       * @member {PIXI.Ticker}
       * @static
       */
      get: function() {
        if (!Ticker2._system) {
          var system = Ticker2._system = new Ticker2();
          system.autoStart = true;
          system._protected = true;
        }
        return Ticker2._system;
      },
      enumerable: false,
      configurable: true
    });
    return Ticker2;
  }()
);
var TickerPlugin = (
  /** @class */
  function() {
    function TickerPlugin2() {
    }
    TickerPlugin2.init = function(options) {
      var _this = this;
      options = Object.assign({
        autoStart: true,
        sharedTicker: false
      }, options);
      Object.defineProperty(this, "ticker", {
        set: function(ticker) {
          if (this._ticker) {
            this._ticker.remove(this.render, this);
          }
          this._ticker = ticker;
          if (ticker) {
            ticker.add(this.render, this, UPDATE_PRIORITY.LOW);
          }
        },
        get: function() {
          return this._ticker;
        }
      });
      this.stop = function() {
        _this._ticker.stop();
      };
      this.start = function() {
        _this._ticker.start();
      };
      this._ticker = null;
      this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();
      if (options.autoStart) {
        this.start();
      }
    };
    TickerPlugin2.destroy = function() {
      if (this._ticker) {
        var oldTicker = this._ticker;
        this.ticker = null;
        oldTicker.destroy();
      }
    };
    TickerPlugin2.extension = ExtensionType.Application;
    return TickerPlugin2;
  }()
);

// node_modules/pixi-viewport/dist/esm/viewport.es.js
var Plugin = class {
  /** The viewport to which this plugin is attached. */
  /**
   * Flags whether this plugin has been "paused".
   *
   * @see Plugin#pause
   * @see Plugin#resume
   */
  /** @param {Viewport} parent */
  constructor(parent) {
    this.parent = parent;
    this.paused = false;
  }
  /** Called when plugin is removed */
  destroy() {
  }
  /** Handler for pointerdown PIXI event */
  down(_e) {
    return false;
  }
  /** Handler for pointermove PIXI event */
  move(_e) {
    return false;
  }
  /** Handler for pointerup PIXI event */
  up(_e) {
    return false;
  }
  /** Handler for wheel event on div */
  wheel(_e) {
    return false;
  }
  /**
   * Called on each tick
   * @param {number} elapsed time in millisecond since last update
   */
  update(_delta) {
  }
  /** Called when the viewport is resized */
  resize() {
  }
  /** Called when the viewport is manually moved */
  reset() {
  }
  /** Pause the plugin */
  pause() {
    this.paused = true;
  }
  /** Un-pause the plugin */
  resume() {
    this.paused = false;
  }
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function createCommonjsModule(fn, basedir, module) {
  return module = {
    path: basedir,
    exports: {},
    require: function(path, base) {
      return commonjsRequire(path, base === void 0 || base === null ? module.path : base);
    }
  }, fn(module, module.exports), module.exports;
}
function commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var penner = createCommonjsModule(function(module, exports) {
  (function() {
    var penner2, umd;
    umd = function(factory) {
      {
        return module.exports = factory;
      }
    };
    penner2 = {
      linear: function(t, b, c, d) {
        return c * t / d + b;
      },
      easeInQuad: function(t, b, c, d) {
        return c * (t /= d) * t + b;
      },
      easeOutQuad: function(t, b, c, d) {
        return -c * (t /= d) * (t - 2) + b;
      },
      easeInOutQuad: function(t, b, c, d) {
        if ((t /= d / 2) < 1) {
          return c / 2 * t * t + b;
        } else {
          return -c / 2 * (--t * (t - 2) - 1) + b;
        }
      },
      easeInCubic: function(t, b, c, d) {
        return c * (t /= d) * t * t + b;
      },
      easeOutCubic: function(t, b, c, d) {
        return c * ((t = t / d - 1) * t * t + 1) + b;
      },
      easeInOutCubic: function(t, b, c, d) {
        if ((t /= d / 2) < 1) {
          return c / 2 * t * t * t + b;
        } else {
          return c / 2 * ((t -= 2) * t * t + 2) + b;
        }
      },
      easeInQuart: function(t, b, c, d) {
        return c * (t /= d) * t * t * t + b;
      },
      easeOutQuart: function(t, b, c, d) {
        return -c * ((t = t / d - 1) * t * t * t - 1) + b;
      },
      easeInOutQuart: function(t, b, c, d) {
        if ((t /= d / 2) < 1) {
          return c / 2 * t * t * t * t + b;
        } else {
          return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
        }
      },
      easeInQuint: function(t, b, c, d) {
        return c * (t /= d) * t * t * t * t + b;
      },
      easeOutQuint: function(t, b, c, d) {
        return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
      },
      easeInOutQuint: function(t, b, c, d) {
        if ((t /= d / 2) < 1) {
          return c / 2 * t * t * t * t * t + b;
        } else {
          return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
        }
      },
      easeInSine: function(t, b, c, d) {
        return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
      },
      easeOutSine: function(t, b, c, d) {
        return c * Math.sin(t / d * (Math.PI / 2)) + b;
      },
      easeInOutSine: function(t, b, c, d) {
        return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
      },
      easeInExpo: function(t, b, c, d) {
        if (t === 0) {
          return b;
        } else {
          return c * Math.pow(2, 10 * (t / d - 1)) + b;
        }
      },
      easeOutExpo: function(t, b, c, d) {
        if (t === d) {
          return b + c;
        } else {
          return c * (-Math.pow(2, -10 * t / d) + 1) + b;
        }
      },
      easeInOutExpo: function(t, b, c, d) {
        if ((t /= d / 2) < 1) {
          return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
        } else {
          return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
        }
      },
      easeInCirc: function(t, b, c, d) {
        return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
      },
      easeOutCirc: function(t, b, c, d) {
        return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
      },
      easeInOutCirc: function(t, b, c, d) {
        if ((t /= d / 2) < 1) {
          return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
        } else {
          return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
        }
      },
      easeInElastic: function(t, b, c, d) {
        var a, p, s;
        s = 1.70158;
        p = 0;
        a = c;
        if (t === 0)
          ;
        else if ((t /= d) === 1)
          ;
        if (!p) {
          p = d * 0.3;
        }
        if (a < Math.abs(c)) {
          a = c;
          s = p / 4;
        } else {
          s = p / (2 * Math.PI) * Math.asin(c / a);
        }
        return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
      },
      easeOutElastic: function(t, b, c, d) {
        var a, p, s;
        s = 1.70158;
        p = 0;
        a = c;
        if (t === 0)
          ;
        else if ((t /= d) === 1)
          ;
        if (!p) {
          p = d * 0.3;
        }
        if (a < Math.abs(c)) {
          a = c;
          s = p / 4;
        } else {
          s = p / (2 * Math.PI) * Math.asin(c / a);
        }
        return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;
      },
      easeInOutElastic: function(t, b, c, d) {
        var a, p, s;
        s = 1.70158;
        p = 0;
        a = c;
        if (t === 0)
          ;
        else if ((t /= d / 2) === 2)
          ;
        if (!p) {
          p = d * (0.3 * 1.5);
        }
        if (a < Math.abs(c)) {
          a = c;
          s = p / 4;
        } else {
          s = p / (2 * Math.PI) * Math.asin(c / a);
        }
        if (t < 1) {
          return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
        } else {
          return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b;
        }
      },
      easeInBack: function(t, b, c, d, s) {
        if (s === void 0) {
          s = 1.70158;
        }
        return c * (t /= d) * t * ((s + 1) * t - s) + b;
      },
      easeOutBack: function(t, b, c, d, s) {
        if (s === void 0) {
          s = 1.70158;
        }
        return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
      },
      easeInOutBack: function(t, b, c, d, s) {
        if (s === void 0) {
          s = 1.70158;
        }
        if ((t /= d / 2) < 1) {
          return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;
        } else {
          return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
        }
      },
      easeInBounce: function(t, b, c, d) {
        var v;
        v = penner2.easeOutBounce(d - t, 0, c, d);
        return c - v + b;
      },
      easeOutBounce: function(t, b, c, d) {
        if ((t /= d) < 1 / 2.75) {
          return c * (7.5625 * t * t) + b;
        } else if (t < 2 / 2.75) {
          return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;
        } else if (t < 2.5 / 2.75) {
          return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;
        } else {
          return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;
        }
      },
      easeInOutBounce: function(t, b, c, d) {
        var v;
        if (t < d / 2) {
          v = penner2.easeInBounce(t * 2, 0, c, d);
          return v * 0.5 + b;
        } else {
          v = penner2.easeOutBounce(t * 2 - d, 0, c, d);
          return v * 0.5 + c * 0.5 + b;
        }
      }
    };
    umd(penner2);
  }).call(commonjsGlobal);
});
function ease(ease2, defaults) {
  if (!ease2) {
    return penner[defaults];
  } else if (typeof ease2 === "function") {
    return ease2;
  } else if (typeof ease2 === "string") {
    return penner[ease2];
  }
}
var DEFAULT_ANIMATE_OPTIONS = {
  removeOnInterrupt: false,
  ease: "linear",
  time: 1e3
};
var Animate = class _Animate extends Plugin {
  /** The starting x-coordinate of the viewport. */
  /** The starting y-coordinate of the viewport. */
  /** The change in the x-coordinate of the viewport through the animation.*/
  /** The change in the y-coordinate of the viewport through the animation. */
  /** Marks whether the center of the viewport is preserved in the animation. */
  /** The starting viewport width. */
  __init() {
    this.startWidth = null;
  }
  /** The starting viewport height. */
  __init2() {
    this.startHeight = null;
  }
  /** The change in the viewport's width through the animation. */
  __init3() {
    this.deltaWidth = null;
  }
  /** The change in the viewport's height through the animation. */
  __init4() {
    this.deltaHeight = null;
  }
  /** The viewport's width post-animation. */
  __init5() {
    this.width = null;
  }
  /** The viewport's height post-animation. */
  __init6() {
    this.height = null;
  }
  /** The time since the animation started. */
  __init7() {
    this.time = 0;
  }
  /**
   * This is called by {@link Viewport.animate}.
   *
   * @param parent
   * @param options
   */
  constructor(parent, options = {}) {
    super(parent);
    _Animate.prototype.__init.call(this);
    _Animate.prototype.__init2.call(this);
    _Animate.prototype.__init3.call(this);
    _Animate.prototype.__init4.call(this);
    _Animate.prototype.__init5.call(this);
    _Animate.prototype.__init6.call(this);
    _Animate.prototype.__init7.call(this);
    this.options = Object.assign({}, DEFAULT_ANIMATE_OPTIONS, options);
    this.options.ease = ease(this.options.ease);
    this.setupPosition();
    this.setupZoom();
    this.time = 0;
  }
  /**
   * Setup `startX`, `startY`, `deltaX`, `deltaY`, `keepCenter`.
   *
   * This is called during construction.
   */
  setupPosition() {
    if (typeof this.options.position !== "undefined") {
      this.startX = this.parent.center.x;
      this.startY = this.parent.center.y;
      this.deltaX = this.options.position.x - this.parent.center.x;
      this.deltaY = this.options.position.y - this.parent.center.y;
      this.keepCenter = false;
    } else {
      this.keepCenter = true;
    }
  }
  /**
   * Setup `startWidth, `startHeight`, `deltaWidth, `deltaHeight, `width`, `height`.
   *
   * This is called during construction.
   */
  setupZoom() {
    this.width = null;
    this.height = null;
    if (typeof this.options.scale !== "undefined") {
      this.width = this.parent.screenWidth / this.options.scale;
    } else if (typeof this.options.scaleX !== "undefined" || typeof this.options.scaleY !== "undefined") {
      if (typeof this.options.scaleX !== "undefined") {
        this.width = this.parent.screenWidth / this.options.scaleX;
      }
      if (typeof this.options.scaleY !== "undefined") {
        this.height = this.parent.screenHeight / this.options.scaleY;
      }
    } else {
      if (typeof this.options.width !== "undefined") {
        this.width = this.options.width;
      }
      if (typeof this.options.height !== "undefined") {
        this.height = this.options.height;
      }
    }
    if (this.width !== null) {
      this.startWidth = this.parent.screenWidthInWorldPixels;
      this.deltaWidth = this.width - this.startWidth;
    }
    if (this.height !== null) {
      this.startHeight = this.parent.screenHeightInWorldPixels;
      this.deltaHeight = this.height - this.startHeight;
    }
  }
  down() {
    if (this.options.removeOnInterrupt) {
      this.parent.plugins.remove("animate");
    }
    return false;
  }
  complete() {
    this.parent.plugins.remove("animate");
    if (this.width !== null) {
      this.parent.fitWidth(this.width, this.keepCenter, this.height === null);
    }
    if (this.height !== null) {
      this.parent.fitHeight(this.height, this.keepCenter, this.width === null);
    }
    if (!this.keepCenter && this.options.position) {
      this.parent.moveCenter(this.options.position);
    }
    this.parent.emit("animate-end", this.parent);
    if (this.options.callbackOnComplete) {
      this.options.callbackOnComplete(this.parent);
    }
  }
  update(elapsed) {
    if (this.paused) {
      return;
    }
    this.time += elapsed;
    const originalZoom = new Point(this.parent.scale.x, this.parent.scale.y);
    if (this.time >= this.options.time) {
      const originalWidth = this.parent.width;
      const originalHeight = this.parent.height;
      this.complete();
      if (originalWidth !== this.parent.width || originalHeight !== this.parent.height) {
        this.parent.emit("zoomed", { viewport: this.parent, original: originalZoom, type: "animate" });
      }
    } else {
      const percent = this.options.ease(this.time, 0, 1, this.options.time);
      if (this.width !== null) {
        const startWidth = this.startWidth;
        const deltaWidth = this.deltaWidth;
        this.parent.fitWidth(
          startWidth + deltaWidth * percent,
          this.keepCenter,
          this.height === null
        );
      }
      if (this.height !== null) {
        const startHeight = this.startHeight;
        const deltaHeight = this.deltaHeight;
        this.parent.fitHeight(
          startHeight + deltaHeight * percent,
          this.keepCenter,
          this.width === null
        );
      }
      if (this.width === null) {
        this.parent.scale.x = this.parent.scale.y;
      } else if (this.height === null) {
        this.parent.scale.y = this.parent.scale.x;
      }
      if (!this.keepCenter) {
        const startX = this.startX;
        const startY = this.startY;
        const deltaX = this.deltaX;
        const deltaY = this.deltaY;
        const original = new Point(this.parent.x, this.parent.y);
        this.parent.moveCenter(startX + deltaX * percent, startY + deltaY * percent);
        this.parent.emit("moved", { viewport: this.parent, original, type: "animate" });
      }
      if (this.width || this.height) {
        this.parent.emit("zoomed", { viewport: this.parent, original: originalZoom, type: "animate" });
      }
    }
  }
};
function _optionalChain$1(ops) {
  let lastAccessLHS = void 0;
  let value = ops[0];
  let i = 1;
  while (i < ops.length) {
    const op = ops[i];
    const fn = ops[i + 1];
    i += 2;
    if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
      return void 0;
    }
    if (op === "access" || op === "optionalAccess") {
      lastAccessLHS = value;
      value = fn(value);
    } else if (op === "call" || op === "optionalCall") {
      value = fn((...args) => value.call(lastAccessLHS, ...args));
      lastAccessLHS = void 0;
    }
  }
  return value;
}
var DEFAULT_BOUNCE_OPTIONS = {
  sides: "all",
  friction: 0.5,
  time: 150,
  ease: "easeInOutSine",
  underflow: "center",
  bounceBox: null
};
var Bounce = class extends Plugin {
  /** The options passed to initialize this plugin, cannot be modified again. */
  /** Holds whether to bounce from left side. */
  /** Holds whether to bounce from top side. */
  /** Holds whether to bounce from right side. */
  /** Holds whether to bounce from bottom side. */
  /** Direction of underflow along x-axis. */
  /** Direction of underflow along y-axis. */
  /** Easing */
  /** Bounce state along x-axis */
  /** Bounce state along y-axis */
  /**
   * This is called by {@link Viewport.bounce}.
   */
  constructor(parent, options = {}) {
    super(parent);
    this.options = Object.assign({}, DEFAULT_BOUNCE_OPTIONS, options);
    this.ease = ease(this.options.ease, "easeInOutSine");
    if (this.options.sides) {
      if (this.options.sides === "all") {
        this.top = this.bottom = this.left = this.right = true;
      } else if (this.options.sides === "horizontal") {
        this.right = this.left = true;
        this.top = this.bottom = false;
      } else if (this.options.sides === "vertical") {
        this.left = this.right = false;
        this.top = this.bottom = true;
      } else {
        this.top = this.options.sides.indexOf("top") !== -1;
        this.bottom = this.options.sides.indexOf("bottom") !== -1;
        this.left = this.options.sides.indexOf("left") !== -1;
        this.right = this.options.sides.indexOf("right") !== -1;
      }
    } else {
      this.left = this.top = this.right = this.bottom = false;
    }
    const clamp = this.options.underflow.toLowerCase();
    if (clamp === "center") {
      this.underflowX = 0;
      this.underflowY = 0;
    } else {
      this.underflowX = clamp.indexOf("left") !== -1 ? -1 : clamp.indexOf("right") !== -1 ? 1 : 0;
      this.underflowY = clamp.indexOf("top") !== -1 ? -1 : clamp.indexOf("bottom") !== -1 ? 1 : 0;
    }
    this.reset();
  }
  isActive() {
    return this.toX !== null || this.toY !== null;
  }
  down() {
    this.toX = this.toY = null;
    return false;
  }
  up() {
    this.bounce();
    return false;
  }
  update(elapsed) {
    if (this.paused) {
      return;
    }
    this.bounce();
    if (this.toX) {
      const toX = this.toX;
      toX.time += elapsed;
      this.parent.emit("moved", { viewport: this.parent, type: "bounce-x" });
      if (toX.time >= this.options.time) {
        this.parent.x = toX.end;
        this.toX = null;
        this.parent.emit("bounce-x-end", this.parent);
      } else {
        this.parent.x = this.ease(toX.time, toX.start, toX.delta, this.options.time);
      }
    }
    if (this.toY) {
      const toY = this.toY;
      toY.time += elapsed;
      this.parent.emit("moved", { viewport: this.parent, type: "bounce-y" });
      if (toY.time >= this.options.time) {
        this.parent.y = toY.end;
        this.toY = null;
        this.parent.emit("bounce-y-end", this.parent);
      } else {
        this.parent.y = this.ease(toY.time, toY.start, toY.delta, this.options.time);
      }
    }
  }
  /** @internal */
  calcUnderflowX() {
    let x;
    switch (this.underflowX) {
      case -1:
        x = 0;
        break;
      case 1:
        x = this.parent.screenWidth - this.parent.screenWorldWidth;
        break;
      default:
        x = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2;
    }
    return x;
  }
  /** @internal */
  calcUnderflowY() {
    let y;
    switch (this.underflowY) {
      case -1:
        y = 0;
        break;
      case 1:
        y = this.parent.screenHeight - this.parent.screenWorldHeight;
        break;
      default:
        y = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2;
    }
    return y;
  }
  oob() {
    const box = this.options.bounceBox;
    if (box) {
      const x1 = typeof box.x === "undefined" ? 0 : box.x;
      const y1 = typeof box.y === "undefined" ? 0 : box.y;
      const width = typeof box.width === "undefined" ? this.parent.worldWidth : box.width;
      const height = typeof box.height === "undefined" ? this.parent.worldHeight : box.height;
      return {
        left: this.parent.left < x1,
        right: this.parent.right > width,
        top: this.parent.top < y1,
        bottom: this.parent.bottom > height,
        topLeft: new Point(
          x1 * this.parent.scale.x,
          y1 * this.parent.scale.y
        ),
        bottomRight: new Point(
          width * this.parent.scale.x - this.parent.screenWidth,
          height * this.parent.scale.y - this.parent.screenHeight
        )
      };
    }
    return {
      left: this.parent.left < 0,
      right: this.parent.right > this.parent.worldWidth,
      top: this.parent.top < 0,
      bottom: this.parent.bottom > this.parent.worldHeight,
      topLeft: new Point(0, 0),
      bottomRight: new Point(
        this.parent.worldWidth * this.parent.scale.x - this.parent.screenWidth,
        this.parent.worldHeight * this.parent.scale.y - this.parent.screenHeight
      )
    };
  }
  bounce() {
    if (this.paused) {
      return;
    }
    let oob;
    let decelerate = this.parent.plugins.get("decelerate", true);
    if (decelerate && (decelerate.x || decelerate.y)) {
      if (decelerate.x && decelerate.percentChangeX === _optionalChain$1([decelerate, "access", (_) => _.options, "optionalAccess", (_2) => _2.friction]) || decelerate.y && decelerate.percentChangeY === _optionalChain$1([decelerate, "access", (_3) => _3.options, "optionalAccess", (_4) => _4.friction])) {
        oob = this.oob();
        if (oob.left && this.left || oob.right && this.right) {
          decelerate.percentChangeX = this.options.friction;
        }
        if (oob.top && this.top || oob.bottom && this.bottom) {
          decelerate.percentChangeY = this.options.friction;
        }
      }
    }
    const drag = this.parent.plugins.get("drag", true) || {};
    const pinch = this.parent.plugins.get("pinch", true) || {};
    decelerate = decelerate || {};
    if (!_optionalChain$1([drag, "optionalAccess", (_5) => _5.active]) && !_optionalChain$1([pinch, "optionalAccess", (_6) => _6.active]) && ((!this.toX || !this.toY) && (!decelerate.x || !decelerate.y))) {
      oob = oob || this.oob();
      const topLeft = oob.topLeft;
      const bottomRight = oob.bottomRight;
      if (!this.toX && !decelerate.x) {
        let x = null;
        if (oob.left && this.left) {
          x = this.parent.screenWorldWidth < this.parent.screenWidth ? this.calcUnderflowX() : -topLeft.x;
        } else if (oob.right && this.right) {
          x = this.parent.screenWorldWidth < this.parent.screenWidth ? this.calcUnderflowX() : -bottomRight.x;
        }
        if (x !== null && this.parent.x !== x) {
          this.toX = { time: 0, start: this.parent.x, delta: x - this.parent.x, end: x };
          this.parent.emit("bounce-x-start", this.parent);
        }
      }
      if (!this.toY && !decelerate.y) {
        let y = null;
        if (oob.top && this.top) {
          y = this.parent.screenWorldHeight < this.parent.screenHeight ? this.calcUnderflowY() : -topLeft.y;
        } else if (oob.bottom && this.bottom) {
          y = this.parent.screenWorldHeight < this.parent.screenHeight ? this.calcUnderflowY() : -bottomRight.y;
        }
        if (y !== null && this.parent.y !== y) {
          this.toY = { time: 0, start: this.parent.y, delta: y - this.parent.y, end: y };
          this.parent.emit("bounce-y-start", this.parent);
        }
      }
    }
  }
  reset() {
    this.toX = this.toY = null;
    this.bounce();
  }
};
var DEFAULT_CLAMP_OPTIONS = {
  left: false,
  right: false,
  top: false,
  bottom: false,
  direction: null,
  underflow: "center"
};
var Clamp = class extends Plugin {
  /** Options used to initialize this plugin, cannot be modified later. */
  /** Last state of viewport */
  /**
   * This is called by {@link Viewport.clamp}.
   */
  constructor(parent, options = {}) {
    super(parent);
    this.options = Object.assign({}, DEFAULT_CLAMP_OPTIONS, options);
    if (this.options.direction) {
      this.options.left = this.options.direction === "x" || this.options.direction === "all" ? true : null;
      this.options.right = this.options.direction === "x" || this.options.direction === "all" ? true : null;
      this.options.top = this.options.direction === "y" || this.options.direction === "all" ? true : null;
      this.options.bottom = this.options.direction === "y" || this.options.direction === "all" ? true : null;
    }
    this.parseUnderflow();
    this.last = { x: null, y: null, scaleX: null, scaleY: null };
    this.update();
  }
  parseUnderflow() {
    const clamp = this.options.underflow.toLowerCase();
    if (clamp === "none") {
      this.noUnderflow = true;
    } else if (clamp === "center") {
      this.underflowX = this.underflowY = 0;
      this.noUnderflow = false;
    } else {
      this.underflowX = clamp.indexOf("left") !== -1 ? -1 : clamp.indexOf("right") !== -1 ? 1 : 0;
      this.underflowY = clamp.indexOf("top") !== -1 ? -1 : clamp.indexOf("bottom") !== -1 ? 1 : 0;
      this.noUnderflow = false;
    }
  }
  move() {
    this.update();
    return false;
  }
  update() {
    if (this.paused) {
      return;
    }
    if (this.parent.x === this.last.x && this.parent.y === this.last.y && this.parent.scale.x === this.last.scaleX && this.parent.scale.y === this.last.scaleY) {
      return;
    }
    const original = { x: this.parent.x, y: this.parent.y };
    const decelerate = this.parent.plugins.decelerate || {};
    if (this.options.left !== null || this.options.right !== null) {
      let moved = false;
      if (!this.noUnderflow && this.parent.screenWorldWidth < this.parent.screenWidth) {
        switch (this.underflowX) {
          case -1:
            if (this.parent.x !== 0) {
              this.parent.x = 0;
              moved = true;
            }
            break;
          case 1:
            if (this.parent.x !== this.parent.screenWidth - this.parent.screenWorldWidth) {
              this.parent.x = this.parent.screenWidth - this.parent.screenWorldWidth;
              moved = true;
            }
            break;
          default:
            if (this.parent.x !== (this.parent.screenWidth - this.parent.screenWorldWidth) / 2) {
              this.parent.x = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2;
              moved = true;
            }
        }
      } else {
        if (this.options.left !== null) {
          if (this.parent.left < (this.options.left === true ? 0 : this.options.left)) {
            this.parent.x = -(this.options.left === true ? 0 : this.options.left) * this.parent.scale.x;
            decelerate.x = 0;
            moved = true;
          }
        }
        if (this.options.right !== null) {
          if (this.parent.right > (this.options.right === true ? this.parent.worldWidth : this.options.right)) {
            this.parent.x = -(this.options.right === true ? this.parent.worldWidth : this.options.right) * this.parent.scale.x + this.parent.screenWidth;
            decelerate.x = 0;
            moved = true;
          }
        }
      }
      if (moved) {
        this.parent.emit("moved", { viewport: this.parent, original, type: "clamp-x" });
      }
    }
    if (this.options.top !== null || this.options.bottom !== null) {
      let moved = false;
      if (!this.noUnderflow && this.parent.screenWorldHeight < this.parent.screenHeight) {
        switch (this.underflowY) {
          case -1:
            if (this.parent.y !== 0) {
              this.parent.y = 0;
              moved = true;
            }
            break;
          case 1:
            if (this.parent.y !== this.parent.screenHeight - this.parent.screenWorldHeight) {
              this.parent.y = this.parent.screenHeight - this.parent.screenWorldHeight;
              moved = true;
            }
            break;
          default:
            if (this.parent.y !== (this.parent.screenHeight - this.parent.screenWorldHeight) / 2) {
              this.parent.y = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2;
              moved = true;
            }
        }
      } else {
        if (this.options.top !== null) {
          if (this.parent.top < (this.options.top === true ? 0 : this.options.top)) {
            this.parent.y = -(this.options.top === true ? 0 : this.options.top) * this.parent.scale.y;
            decelerate.y = 0;
            moved = true;
          }
        }
        if (this.options.bottom !== null) {
          if (this.parent.bottom > (this.options.bottom === true ? this.parent.worldHeight : this.options.bottom)) {
            this.parent.y = -(this.options.bottom === true ? this.parent.worldHeight : this.options.bottom) * this.parent.scale.y + this.parent.screenHeight;
            decelerate.y = 0;
            moved = true;
          }
        }
      }
      if (moved) {
        this.parent.emit("moved", { viewport: this.parent, original, type: "clamp-y" });
      }
    }
    this.last.x = this.parent.x;
    this.last.y = this.parent.y;
    this.last.scaleX = this.parent.scale.x;
    this.last.scaleY = this.parent.scale.y;
  }
  reset() {
    this.update();
  }
};
var DEFAULT_CLAMP_ZOOM_OPTIONS = {
  minWidth: null,
  minHeight: null,
  maxWidth: null,
  maxHeight: null,
  minScale: null,
  maxScale: null
};
var ClampZoom = class extends Plugin {
  /**
   * This is called by {@link Viewport.clampZoom}.
   */
  constructor(parent, options = {}) {
    super(parent);
    this.options = Object.assign({}, DEFAULT_CLAMP_ZOOM_OPTIONS, options);
    this.clamp();
  }
  resize() {
    this.clamp();
  }
  /** Clamp the viewport scale zoom) */
  clamp() {
    if (this.paused) {
      return;
    }
    if (this.options.minWidth || this.options.minHeight || this.options.maxWidth || this.options.maxHeight) {
      let width = this.parent.worldScreenWidth;
      let height = this.parent.worldScreenHeight;
      if (this.options.minWidth !== null && width < this.options.minWidth) {
        const original = this.parent.scale.x;
        this.parent.fitWidth(this.options.minWidth, false, false, true);
        this.parent.scale.y *= this.parent.scale.x / original;
        width = this.parent.worldScreenWidth;
        height = this.parent.worldScreenHeight;
        this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
      }
      if (this.options.maxWidth !== null && width > this.options.maxWidth) {
        const original = this.parent.scale.x;
        this.parent.fitWidth(this.options.maxWidth, false, false, true);
        this.parent.scale.y *= this.parent.scale.x / original;
        width = this.parent.worldScreenWidth;
        height = this.parent.worldScreenHeight;
        this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
      }
      if (this.options.minHeight !== null && height < this.options.minHeight) {
        const original = this.parent.scale.y;
        this.parent.fitHeight(this.options.minHeight, false, false, true);
        this.parent.scale.x *= this.parent.scale.y / original;
        width = this.parent.worldScreenWidth;
        height = this.parent.worldScreenHeight;
        this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
      }
      if (this.options.maxHeight !== null && height > this.options.maxHeight) {
        const original = this.parent.scale.y;
        this.parent.fitHeight(this.options.maxHeight, false, false, true);
        this.parent.scale.x *= this.parent.scale.y / original;
        this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
      }
    } else if (this.options.minScale || this.options.maxScale) {
      const minScale = { x: null, y: null };
      const maxScale = { x: null, y: null };
      if (typeof this.options.minScale === "number") {
        minScale.x = this.options.minScale;
        minScale.y = this.options.minScale;
      } else if (this.options.minScale !== null) {
        const optsMinScale = this.options.minScale;
        minScale.x = typeof optsMinScale.x === "undefined" ? null : optsMinScale.x;
        minScale.y = typeof optsMinScale.y === "undefined" ? null : optsMinScale.y;
      }
      if (typeof this.options.maxScale === "number") {
        maxScale.x = this.options.maxScale;
        maxScale.y = this.options.maxScale;
      } else if (this.options.maxScale !== null) {
        const optsMaxScale = this.options.maxScale;
        maxScale.x = typeof optsMaxScale.x === "undefined" ? null : optsMaxScale.x;
        maxScale.y = typeof optsMaxScale.y === "undefined" ? null : optsMaxScale.y;
      }
      let scaleX = this.parent.scale.x;
      let scaleY = this.parent.scale.y;
      if (minScale.x !== null && scaleX < minScale.x) {
        scaleX = minScale.x;
      }
      if (maxScale.x !== null && scaleX > maxScale.x) {
        scaleX = maxScale.x;
      }
      if (minScale.y !== null && scaleY < minScale.y) {
        scaleY = minScale.y;
      }
      if (maxScale.y !== null && scaleY > maxScale.y) {
        scaleY = maxScale.y;
      }
      if (scaleX !== this.parent.scale.x || scaleY !== this.parent.scale.y) {
        this.parent.scale.set(scaleX, scaleY);
        this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
      }
    }
  }
  reset() {
    this.clamp();
  }
};
var DEFAULT_DECELERATE_OPTIONS = {
  friction: 0.98,
  bounce: 0.8,
  minSpeed: 0.01
};
var TP = 16;
var Decelerate = class extends Plugin {
  /** Options used to initialize this plugin. */
  /**
   * x-component of the velocity of viewport provided by this plugin, at the current time.
   *
   * This is measured in px/frame, where a frame is normalized to 16 milliseconds.
   */
  /**
   * y-component of the velocity of the viewport provided by this plugin, at the current time.
   *
   * This is measured in px/frame, where a frame is normalized to 16 milliseconds.
   */
  /**
   * The decay factor for the x-component of the viewport.
   *
   * The viewport's velocity decreased by this amount each 16 milliseconds.
   */
  /**
   * The decay factor for the y-component of the viewport.
   *
   * The viewport's velocity decreased by this amount each 16 milliseconds.
   */
  /** Saved list of recent viewport position snapshots, to estimate velocity. */
  /** The time since the user released panning of the viewport. */
  /**
   * This is called by {@link Viewport.decelerate}.
   */
  constructor(parent, options = {}) {
    super(parent);
    this.options = Object.assign({}, DEFAULT_DECELERATE_OPTIONS, options);
    this.saved = [];
    this.timeSinceRelease = 0;
    this.reset();
    this.parent.on("moved", (data) => this.moved(data));
  }
  down() {
    this.saved = [];
    this.x = this.y = null;
    return false;
  }
  isActive() {
    return !!(this.x || this.y);
  }
  move() {
    if (this.paused) {
      return false;
    }
    const count = this.parent.input.count();
    if (count === 1 || count > 1 && !this.parent.plugins.get("pinch", true)) {
      this.saved.push({ x: this.parent.x, y: this.parent.y, time: performance.now() });
      if (this.saved.length > 60) {
        this.saved.splice(0, 30);
      }
    }
    return false;
  }
  /** Listener to viewport's "moved" event. */
  moved(data) {
    if (this.saved.length) {
      const last = this.saved[this.saved.length - 1];
      if (data.type === "clamp-x") {
        if (last.x === data.original.x) {
          last.x = this.parent.x;
        }
      } else if (data.type === "clamp-y") {
        if (last.y === data.original.y) {
          last.y = this.parent.y;
        }
      }
    }
  }
  up() {
    if (this.parent.input.count() === 0 && this.saved.length) {
      const now = performance.now();
      for (const save of this.saved) {
        if (save.time >= now - 100) {
          const time = now - save.time;
          this.x = (this.parent.x - save.x) / time;
          this.y = (this.parent.y - save.y) / time;
          this.percentChangeX = this.percentChangeY = this.options.friction;
          this.timeSinceRelease = 0;
          break;
        }
      }
    }
    return false;
  }
  /**
   * Manually activate deceleration, starting from the (x, y) velocity components passed in the options.
   *
   * @param {object} options
   * @param {number} [options.x] - Specify x-component of initial velocity.
   * @param {number} [options.y] - Specify y-component of initial velocity.
   */
  activate(options) {
    options = options || {};
    if (typeof options.x !== "undefined") {
      this.x = options.x;
      this.percentChangeX = this.options.friction;
    }
    if (typeof options.y !== "undefined") {
      this.y = options.y;
      this.percentChangeY = this.options.friction;
    }
  }
  update(elapsed) {
    if (this.paused) {
      return;
    }
    const moved = this.x || this.y;
    const ti = this.timeSinceRelease;
    const tf = this.timeSinceRelease + elapsed;
    if (this.x) {
      const k = this.percentChangeX;
      const lnk = Math.log(k);
      this.parent.x += this.x * TP / lnk * (Math.pow(k, tf / TP) - Math.pow(k, ti / TP));
      this.x *= Math.pow(this.percentChangeX, elapsed / TP);
    }
    if (this.y) {
      const k = this.percentChangeY;
      const lnk = Math.log(k);
      this.parent.y += this.y * TP / lnk * (Math.pow(k, tf / TP) - Math.pow(k, ti / TP));
      this.y *= Math.pow(this.percentChangeY, elapsed / TP);
    }
    this.timeSinceRelease += elapsed;
    if (this.x && this.y) {
      if (Math.abs(this.x) < this.options.minSpeed && Math.abs(this.y) < this.options.minSpeed) {
        this.x = 0;
        this.y = 0;
      }
    } else {
      if (Math.abs(this.x || 0) < this.options.minSpeed) {
        this.x = 0;
      }
      if (Math.abs(this.y || 0) < this.options.minSpeed) {
        this.y = 0;
      }
    }
    if (moved) {
      this.parent.emit("moved", { viewport: this.parent, type: "decelerate" });
    }
  }
  reset() {
    this.x = this.y = null;
  }
};
var DEFAULT_DRAG_OPTIONS = {
  direction: "all",
  pressDrag: true,
  wheel: true,
  wheelScroll: 1,
  reverse: false,
  clampWheel: false,
  underflow: "center",
  factor: 1,
  mouseButtons: "all",
  keyToPress: null,
  ignoreKeyToPressOnTouch: false,
  lineHeight: 20,
  wheelSwapAxes: false
};
var Drag = class _Drag extends Plugin {
  /** Options used to initialize this plugin, cannot be modified later. */
  /** Flags when viewport is moving. */
  /** Factor to apply from {@link IDecelerateOptions}'s reverse. */
  /** Holds whether dragging is enabled along the x-axis. */
  /** Holds whether dragging is enabled along the y-axis. */
  /** Flags whether the keys required to drag are pressed currently. */
  /** Holds whether the left, center, and right buttons are required to pan. */
  /** Underflow factor along x-axis */
  /** Underflow factor along y-axis */
  /** Last pointer position while panning. */
  /** The ID of the pointer currently panning the viewport. */
  /** Array of event-handlers for window */
  __init() {
    this.windowEventHandlers = new Array();
  }
  /**
   * This is called by {@link Viewport.drag}.
   */
  constructor(parent, options = {}) {
    super(parent);
    _Drag.prototype.__init.call(this);
    this.options = Object.assign({}, DEFAULT_DRAG_OPTIONS, options);
    this.moved = false;
    this.reverse = this.options.reverse ? 1 : -1;
    this.xDirection = !this.options.direction || this.options.direction === "all" || this.options.direction === "x";
    this.yDirection = !this.options.direction || this.options.direction === "all" || this.options.direction === "y";
    this.keyIsPressed = false;
    this.parseUnderflow();
    this.mouseButtons(this.options.mouseButtons);
    if (this.options.keyToPress) {
      this.handleKeyPresses(this.options.keyToPress);
    }
  }
  /**
   * Handles keypress events and set the keyIsPressed boolean accordingly
   *
   * @param {array} codes - key codes that can be used to trigger drag event
   */
  handleKeyPresses(codes) {
    const keydownHandler = (e) => {
      if (codes.includes(e.code)) {
        this.keyIsPressed = true;
      }
    };
    const keyupHandler = (e) => {
      if (codes.includes(e.code)) {
        this.keyIsPressed = false;
      }
    };
    this.addWindowEventHandler("keyup", keyupHandler);
    this.addWindowEventHandler("keydown", keydownHandler);
  }
  addWindowEventHandler(event, handler) {
    window.addEventListener(event, handler);
    this.windowEventHandlers.push({ event, handler });
  }
  destroy() {
    this.windowEventHandlers.forEach(({ event, handler }) => {
      window.removeEventListener(event, handler);
    });
  }
  /**
   * initialize mousebuttons array
   * @param {string} buttons
   */
  mouseButtons(buttons) {
    if (!buttons || buttons === "all") {
      this.mouse = [true, true, true];
    } else {
      this.mouse = [
        buttons.indexOf("left") !== -1,
        buttons.indexOf("middle") !== -1,
        buttons.indexOf("right") !== -1
      ];
    }
  }
  parseUnderflow() {
    const clamp = this.options.underflow.toLowerCase();
    if (clamp === "center") {
      this.underflowX = 0;
      this.underflowY = 0;
    } else {
      if (clamp.includes("left")) {
        this.underflowX = -1;
      } else if (clamp.includes("right")) {
        this.underflowX = 1;
      } else {
        this.underflowX = 0;
      }
      if (clamp.includes("top")) {
        this.underflowY = -1;
      } else if (clamp.includes("bottom")) {
        this.underflowY = 1;
      } else {
        this.underflowY = 0;
      }
    }
  }
  /**
   * @param {PIXI.InteractionEvent} event
   * @returns {boolean}
   */
  checkButtons(event) {
    const isMouse = event.data.pointerType === "mouse";
    const count = this.parent.input.count();
    if (count === 1 || count > 1 && !this.parent.plugins.get("pinch", true)) {
      if (!isMouse || this.mouse[event.data.button]) {
        return true;
      }
    }
    return false;
  }
  /**
   * @param {PIXI.InteractionEvent} event
   * @returns {boolean}
   */
  checkKeyPress(event) {
    return !this.options.keyToPress || this.keyIsPressed || this.options.ignoreKeyToPressOnTouch && event.data.pointerType === "touch";
  }
  down(event) {
    if (this.paused || !this.options.pressDrag) {
      return false;
    }
    if (this.checkButtons(event) && this.checkKeyPress(event)) {
      this.last = { x: event.data.global.x, y: event.data.global.y };
      this.current = event.data.pointerId;
      return true;
    }
    this.last = null;
    return false;
  }
  get active() {
    return this.moved;
  }
  move(event) {
    if (this.paused || !this.options.pressDrag) {
      return false;
    }
    if (this.last && this.current === event.data.pointerId) {
      const x = event.data.global.x;
      const y = event.data.global.y;
      const count = this.parent.input.count();
      if (count === 1 || count > 1 && !this.parent.plugins.get("pinch", true)) {
        const distX = x - this.last.x;
        const distY = y - this.last.y;
        if (this.moved || (this.xDirection && this.parent.input.checkThreshold(distX) || this.yDirection && this.parent.input.checkThreshold(distY))) {
          const newPoint = { x, y };
          if (this.xDirection) {
            this.parent.x += (newPoint.x - this.last.x) * this.options.factor;
          }
          if (this.yDirection) {
            this.parent.y += (newPoint.y - this.last.y) * this.options.factor;
          }
          this.last = newPoint;
          if (!this.moved) {
            this.parent.emit("drag-start", {
              event,
              screen: new Point(this.last.x, this.last.y),
              world: this.parent.toWorld(new Point(this.last.x, this.last.y)),
              viewport: this.parent
            });
          }
          this.moved = true;
          this.parent.emit("moved", { viewport: this.parent, type: "drag" });
          return true;
        }
      } else {
        this.moved = false;
      }
    }
    return false;
  }
  up(event) {
    if (this.paused) {
      return false;
    }
    const touches = this.parent.input.touches;
    if (touches.length === 1) {
      const pointer = touches[0];
      if (pointer.last) {
        this.last = { x: pointer.last.x, y: pointer.last.y };
        this.current = pointer.id;
      }
      this.moved = false;
      return true;
    } else if (this.last) {
      if (this.moved) {
        const screen = new Point(this.last.x, this.last.y);
        this.parent.emit("drag-end", {
          event,
          screen,
          world: this.parent.toWorld(screen),
          viewport: this.parent
        });
        this.last = null;
        this.moved = false;
        return true;
      }
    }
    return false;
  }
  wheel(event) {
    if (this.paused) {
      return false;
    }
    if (this.options.wheel) {
      const wheel = this.parent.plugins.get("wheel", true);
      if (!wheel || !wheel.options.wheelZoom && !event.ctrlKey) {
        const step = event.deltaMode ? this.options.lineHeight : 1;
        const deltas = [event.deltaX, event.deltaY];
        const [deltaX, deltaY] = this.options.wheelSwapAxes ? deltas.reverse() : deltas;
        if (this.xDirection) {
          this.parent.x += deltaX * step * this.options.wheelScroll * this.reverse;
        }
        if (this.yDirection) {
          this.parent.y += deltaY * step * this.options.wheelScroll * this.reverse;
        }
        if (this.options.clampWheel) {
          this.clamp();
        }
        this.parent.emit("wheel-scroll", this.parent);
        this.parent.emit("moved", { viewport: this.parent, type: "wheel" });
        if (!this.parent.options.passiveWheel) {
          event.preventDefault();
        }
        if (this.parent.options.stopPropagation) {
          event.stopPropagation();
        }
        return true;
      }
    }
    return false;
  }
  resume() {
    this.last = null;
    this.paused = false;
  }
  clamp() {
    const decelerate = this.parent.plugins.get("decelerate", true) || {};
    if (this.options.clampWheel !== "y") {
      if (this.parent.screenWorldWidth < this.parent.screenWidth) {
        switch (this.underflowX) {
          case -1:
            this.parent.x = 0;
            break;
          case 1:
            this.parent.x = this.parent.screenWidth - this.parent.screenWorldWidth;
            break;
          default:
            this.parent.x = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2;
        }
      } else if (this.parent.left < 0) {
        this.parent.x = 0;
        decelerate.x = 0;
      } else if (this.parent.right > this.parent.worldWidth) {
        this.parent.x = -this.parent.worldWidth * this.parent.scale.x + this.parent.screenWidth;
        decelerate.x = 0;
      }
    }
    if (this.options.clampWheel !== "x") {
      if (this.parent.screenWorldHeight < this.parent.screenHeight) {
        switch (this.underflowY) {
          case -1:
            this.parent.y = 0;
            break;
          case 1:
            this.parent.y = this.parent.screenHeight - this.parent.screenWorldHeight;
            break;
          default:
            this.parent.y = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2;
        }
      } else {
        if (this.parent.top < 0) {
          this.parent.y = 0;
          decelerate.y = 0;
        }
        if (this.parent.bottom > this.parent.worldHeight) {
          this.parent.y = -this.parent.worldHeight * this.parent.scale.y + this.parent.screenHeight;
          decelerate.y = 0;
        }
      }
    }
  }
};
var DEFAULT_FOLLOW_OPTIONS = {
  speed: 0,
  acceleration: null,
  radius: null
};
var Follow = class extends Plugin {
  /** The options used to initialize this plugin. */
  /** The target this plugin will make the viewport follow. */
  /** The velocity provided the viewport by following, at the current time. */
  /**
   * This is called by {@link Viewport.follow}.
   *
   * @param parent
   * @param target - target to follow
   * @param options
   */
  constructor(parent, target, options = {}) {
    super(parent);
    this.target = target;
    this.options = Object.assign({}, DEFAULT_FOLLOW_OPTIONS, options);
    this.velocity = { x: 0, y: 0 };
  }
  update(elapsed) {
    if (this.paused) {
      return;
    }
    const center = this.parent.center;
    let toX = this.target.x;
    let toY = this.target.y;
    if (this.options.radius) {
      const distance = Math.sqrt(Math.pow(this.target.y - center.y, 2) + Math.pow(this.target.x - center.x, 2));
      if (distance > this.options.radius) {
        const angle = Math.atan2(this.target.y - center.y, this.target.x - center.x);
        toX = this.target.x - Math.cos(angle) * this.options.radius;
        toY = this.target.y - Math.sin(angle) * this.options.radius;
      } else {
        return;
      }
    }
    const deltaX = toX - center.x;
    const deltaY = toY - center.y;
    if (deltaX || deltaY) {
      if (this.options.speed) {
        if (this.options.acceleration) {
          const angle = Math.atan2(toY - center.y, toX - center.x);
          const distance = Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
          if (distance) {
            const decelerationDistance = (Math.pow(this.velocity.x, 2) + Math.pow(this.velocity.y, 2)) / (2 * this.options.acceleration);
            if (distance > decelerationDistance) {
              this.velocity = {
                x: Math.min(this.velocity.x + (this.options.acceleration * elapsed, this.options.speed)),
                y: Math.min(this.velocity.y + (this.options.acceleration * elapsed, this.options.speed))
              };
            } else {
              this.velocity = {
                x: Math.max(this.velocity.x - this.options.acceleration * this.options.speed, 0),
                y: Math.max(this.velocity.y - this.options.acceleration * this.options.speed, 0)
              };
            }
            const changeX = Math.cos(angle) * this.velocity.x;
            const changeY = Math.sin(angle) * this.velocity.y;
            const x = Math.abs(changeX) > Math.abs(deltaX) ? toX : center.x + changeX;
            const y = Math.abs(changeY) > Math.abs(deltaY) ? toY : center.y + changeY;
            this.parent.moveCenter(x, y);
            this.parent.emit("moved", { viewport: this.parent, type: "follow" });
          }
        } else {
          const angle = Math.atan2(toY - center.y, toX - center.x);
          const changeX = Math.cos(angle) * this.options.speed;
          const changeY = Math.sin(angle) * this.options.speed;
          const x = Math.abs(changeX) > Math.abs(deltaX) ? toX : center.x + changeX;
          const y = Math.abs(changeY) > Math.abs(deltaY) ? toY : center.y + changeY;
          this.parent.moveCenter(x, y);
          this.parent.emit("moved", { viewport: this.parent, type: "follow" });
        }
      } else {
        this.parent.moveCenter(toX, toY);
        this.parent.emit("moved", { viewport: this.parent, type: "follow" });
      }
    }
  }
};
var MOUSE_EDGES_OPTIONS = {
  radius: null,
  distance: null,
  top: null,
  bottom: null,
  left: null,
  right: null,
  speed: 8,
  reverse: false,
  noDecelerate: false,
  linear: false,
  allowButtons: false
};
var MouseEdges = class extends Plugin {
  /** Options used to initialize this plugin, cannot be modified later. */
  /** Factor from reverse option. */
  /** Radius squared */
  /** Scroll region size on the left side. */
  /** Scroll region size on the top size. */
  /** Scroll region size on the right side. */
  /** Scroll region size on the bottom side. */
  /**
   * This is called by {@link Viewport.mouseEdges}.
   */
  constructor(parent, options = {}) {
    super(parent);
    this.options = Object.assign({}, MOUSE_EDGES_OPTIONS, options);
    this.reverse = this.options.reverse ? 1 : -1;
    this.radiusSquared = typeof this.options.radius === "number" ? Math.pow(this.options.radius, 2) : null;
    this.resize();
  }
  resize() {
    const distance = this.options.distance;
    if (distance !== null) {
      this.left = distance;
      this.top = distance;
      this.right = this.parent.screenWidth - distance;
      this.bottom = this.parent.screenHeight - distance;
    } else if (!this.options.radius) {
      this.left = this.options.left;
      this.top = this.options.top;
      this.right = this.options.right === null ? null : this.parent.screenWidth - this.options.right;
      this.bottom = this.options.bottom === null ? null : this.parent.screenHeight - this.options.bottom;
    }
  }
  down() {
    if (this.paused) {
      return false;
    }
    if (!this.options.allowButtons) {
      this.horizontal = this.vertical = null;
    }
    return false;
  }
  move(event) {
    if (this.paused) {
      return false;
    }
    if (event.data.pointerType !== "mouse" && event.data.identifier !== 1 || !this.options.allowButtons && event.data.buttons !== 0) {
      return false;
    }
    const x = event.data.global.x;
    const y = event.data.global.y;
    if (this.radiusSquared) {
      const center = this.parent.toScreen(this.parent.center);
      const distance = Math.pow(center.x - x, 2) + Math.pow(center.y - y, 2);
      if (distance >= this.radiusSquared) {
        const angle = Math.atan2(center.y - y, center.x - x);
        if (this.options.linear) {
          this.horizontal = Math.round(Math.cos(angle)) * this.options.speed * this.reverse * (60 / 1e3);
          this.vertical = Math.round(Math.sin(angle)) * this.options.speed * this.reverse * (60 / 1e3);
        } else {
          this.horizontal = Math.cos(angle) * this.options.speed * this.reverse * (60 / 1e3);
          this.vertical = Math.sin(angle) * this.options.speed * this.reverse * (60 / 1e3);
        }
      } else {
        if (this.horizontal) {
          this.decelerateHorizontal();
        }
        if (this.vertical) {
          this.decelerateVertical();
        }
        this.horizontal = this.vertical = 0;
      }
    } else {
      if (this.left !== null && x < this.left) {
        this.horizontal = Number(this.reverse) * this.options.speed * (60 / 1e3);
      } else if (this.right !== null && x > this.right) {
        this.horizontal = -1 * this.reverse * this.options.speed * (60 / 1e3);
      } else {
        this.decelerateHorizontal();
        this.horizontal = 0;
      }
      if (this.top !== null && y < this.top) {
        this.vertical = Number(this.reverse) * this.options.speed * (60 / 1e3);
      } else if (this.bottom !== null && y > this.bottom) {
        this.vertical = -1 * this.reverse * this.options.speed * (60 / 1e3);
      } else {
        this.decelerateVertical();
        this.vertical = 0;
      }
    }
    return false;
  }
  decelerateHorizontal() {
    const decelerate = this.parent.plugins.get("decelerate", true);
    if (this.horizontal && decelerate && !this.options.noDecelerate) {
      decelerate.activate({ x: this.horizontal * this.options.speed * this.reverse / (1e3 / 60) });
    }
  }
  decelerateVertical() {
    const decelerate = this.parent.plugins.get("decelerate", true);
    if (this.vertical && decelerate && !this.options.noDecelerate) {
      decelerate.activate({ y: this.vertical * this.options.speed * this.reverse / (1e3 / 60) });
    }
  }
  up() {
    if (this.paused) {
      return false;
    }
    if (this.horizontal) {
      this.decelerateHorizontal();
    }
    if (this.vertical) {
      this.decelerateVertical();
    }
    this.horizontal = this.vertical = null;
    return false;
  }
  update() {
    if (this.paused) {
      return;
    }
    if (this.horizontal || this.vertical) {
      const center = this.parent.center;
      if (this.horizontal) {
        center.x += this.horizontal * this.options.speed;
      }
      if (this.vertical) {
        center.y += this.vertical * this.options.speed;
      }
      this.parent.moveCenter(center);
      this.parent.emit("moved", { viewport: this.parent, type: "mouse-edges" });
    }
  }
};
var DEFAULT_PINCH_OPTIONS = {
  noDrag: false,
  percent: 1,
  center: null,
  factor: 1,
  axis: "all"
};
var Pinch = class _Pinch extends Plugin {
  /** Options used to initialize this plugin. */
  /** Flags whether this plugin is active, i.e. a pointer is down on the viewport. */
  __init() {
    this.active = false;
  }
  /** Flags whether the viewport is being pinched. */
  __init2() {
    this.pinching = false;
  }
  __init3() {
    this.moved = false;
  }
  /**
   * This is called by {@link Viewport.pinch}.
   */
  constructor(parent, options = {}) {
    super(parent);
    _Pinch.prototype.__init.call(this);
    _Pinch.prototype.__init2.call(this);
    _Pinch.prototype.__init3.call(this);
    this.options = Object.assign({}, DEFAULT_PINCH_OPTIONS, options);
  }
  down() {
    if (this.parent.input.count() >= 2) {
      this.active = true;
      return true;
    }
    return false;
  }
  isAxisX() {
    return ["all", "x"].includes(this.options.axis);
  }
  isAxisY() {
    return ["all", "y"].includes(this.options.axis);
  }
  move(e) {
    if (this.paused || !this.active) {
      return false;
    }
    const x = e.data.global.x;
    const y = e.data.global.y;
    const pointers = this.parent.input.touches;
    if (pointers.length >= 2) {
      const first = pointers[0];
      const second = pointers[1];
      const last = first.last && second.last ? Math.sqrt(Math.pow(second.last.x - first.last.x, 2) + Math.pow(second.last.y - first.last.y, 2)) : null;
      if (first.id === e.data.pointerId) {
        first.last = { x, y, data: e.data };
      } else if (second.id === e.data.pointerId) {
        second.last = { x, y, data: e.data };
      }
      if (last) {
        let oldPoint;
        const point = {
          x: first.last.x + (second.last.x - first.last.x) / 2,
          y: first.last.y + (second.last.y - first.last.y) / 2
        };
        if (!this.options.center) {
          oldPoint = this.parent.toLocal(point);
        }
        let dist = Math.sqrt(Math.pow(
          second.last.x - first.last.x,
          2
        ) + Math.pow(second.last.y - first.last.y, 2));
        dist = dist === 0 ? dist = 1e-10 : dist;
        const change = (1 - last / dist) * this.options.percent * (this.isAxisX() ? this.parent.scale.x : this.parent.scale.y);
        if (this.isAxisX()) {
          this.parent.scale.x += change;
        }
        if (this.isAxisY()) {
          this.parent.scale.y += change;
        }
        this.parent.emit("zoomed", { viewport: this.parent, type: "pinch", center: point });
        const clamp = this.parent.plugins.get("clamp-zoom", true);
        if (clamp) {
          clamp.clamp();
        }
        if (this.options.center) {
          this.parent.moveCenter(this.options.center);
        } else {
          const newPoint = this.parent.toGlobal(oldPoint);
          this.parent.x += (point.x - newPoint.x) * this.options.factor;
          this.parent.y += (point.y - newPoint.y) * this.options.factor;
          this.parent.emit("moved", { viewport: this.parent, type: "pinch" });
        }
        if (!this.options.noDrag && this.lastCenter) {
          this.parent.x += (point.x - this.lastCenter.x) * this.options.factor;
          this.parent.y += (point.y - this.lastCenter.y) * this.options.factor;
          this.parent.emit("moved", { viewport: this.parent, type: "pinch" });
        }
        this.lastCenter = point;
        this.moved = true;
      } else if (!this.pinching) {
        this.parent.emit("pinch-start", this.parent);
        this.pinching = true;
      }
      return true;
    }
    return false;
  }
  up() {
    if (this.pinching) {
      if (this.parent.input.touches.length <= 1) {
        this.active = false;
        this.lastCenter = null;
        this.pinching = false;
        this.moved = false;
        this.parent.emit("pinch-end", this.parent);
        return true;
      }
    }
    return false;
  }
};
var DEFAULT_SNAP_OPTIONS = {
  topLeft: false,
  friction: 0.8,
  time: 1e3,
  ease: "easeInOutSine",
  interrupt: true,
  removeOnComplete: false,
  removeOnInterrupt: false,
  forceStart: false
};
var Snap = class extends Plugin {
  /**
   * This is called by {@link Viewport.snap}.
   */
  constructor(parent, x, y, options = {}) {
    super(parent);
    this.options = Object.assign({}, DEFAULT_SNAP_OPTIONS, options);
    this.ease = ease(options.ease, "easeInOutSine");
    this.x = x;
    this.y = y;
    if (this.options.forceStart) {
      this.snapStart();
    }
  }
  snapStart() {
    this.percent = 0;
    this.snapping = { time: 0 };
    const current = this.options.topLeft ? this.parent.corner : this.parent.center;
    this.deltaX = this.x - current.x;
    this.deltaY = this.y - current.y;
    this.startX = current.x;
    this.startY = current.y;
    this.parent.emit("snap-start", this.parent);
  }
  wheel() {
    if (this.options.removeOnInterrupt) {
      this.parent.plugins.remove("snap");
    }
    return false;
  }
  down() {
    if (this.options.removeOnInterrupt) {
      this.parent.plugins.remove("snap");
    } else if (this.options.interrupt) {
      this.snapping = null;
    }
    return false;
  }
  up() {
    if (this.parent.input.count() === 0) {
      const decelerate = this.parent.plugins.get("decelerate", true);
      if (decelerate && (decelerate.x || decelerate.y)) {
        decelerate.percentChangeX = decelerate.percentChangeY = this.options.friction;
      }
    }
    return false;
  }
  update(elapsed) {
    if (this.paused) {
      return;
    }
    if (this.options.interrupt && this.parent.input.count() !== 0) {
      return;
    }
    if (!this.snapping) {
      const current = this.options.topLeft ? this.parent.corner : this.parent.center;
      if (current.x !== this.x || current.y !== this.y) {
        this.snapStart();
      }
    } else {
      const snapping = this.snapping;
      snapping.time += elapsed;
      let finished;
      let x;
      let y;
      const startX = this.startX;
      const startY = this.startY;
      const deltaX = this.deltaX;
      const deltaY = this.deltaY;
      if (snapping.time > this.options.time) {
        finished = true;
        x = startX + deltaX;
        y = startY + deltaY;
      } else {
        const percent = this.ease(snapping.time, 0, 1, this.options.time);
        x = startX + deltaX * percent;
        y = startY + deltaY * percent;
      }
      if (this.options.topLeft) {
        this.parent.moveCorner(x, y);
      } else {
        this.parent.moveCenter(x, y);
      }
      this.parent.emit("moved", { viewport: this.parent, type: "snap" });
      if (finished) {
        if (this.options.removeOnComplete) {
          this.parent.plugins.remove("snap");
        }
        this.parent.emit("snap-end", this.parent);
        this.snapping = null;
      }
    }
  }
};
var DEFAULT_SNAP_ZOOM_OPTIONS = {
  width: 0,
  height: 0,
  time: 1e3,
  ease: "easeInOutSine",
  center: null,
  interrupt: true,
  removeOnComplete: false,
  removeOnInterrupt: false,
  forceStart: false,
  noMove: false
};
var SnapZoom = class extends Plugin {
  /**
   * This is called by {@link Viewport.snapZoom}.
   */
  constructor(parent, options = {}) {
    super(parent);
    this.options = Object.assign({}, DEFAULT_SNAP_ZOOM_OPTIONS, options);
    this.ease = ease(this.options.ease);
    this.xIndependent = false;
    this.yIndependent = false;
    this.xScale = 0;
    this.yScale = 0;
    if (this.options.width > 0) {
      this.xScale = parent.screenWidth / this.options.width;
      this.xIndependent = true;
    }
    if (this.options.height > 0) {
      this.yScale = parent.screenHeight / this.options.height;
      this.yIndependent = true;
    }
    this.xScale = this.xIndependent ? this.xScale : this.yScale;
    this.yScale = this.yIndependent ? this.yScale : this.xScale;
    if (this.options.time === 0) {
      parent.container.scale.x = this.xScale;
      parent.container.scale.y = this.yScale;
      if (this.options.removeOnComplete) {
        this.parent.plugins.remove("snap-zoom");
      }
    } else if (options.forceStart) {
      this.createSnapping();
    }
  }
  createSnapping() {
    const startWorldScreenWidth = this.parent.worldScreenWidth;
    const startWorldScreenHeight = this.parent.worldScreenHeight;
    const endWorldScreenWidth = this.parent.screenWidth / this.xScale;
    const endWorldScreenHeight = this.parent.screenHeight / this.yScale;
    this.snapping = {
      time: 0,
      startX: startWorldScreenWidth,
      startY: startWorldScreenHeight,
      deltaX: endWorldScreenWidth - startWorldScreenWidth,
      deltaY: endWorldScreenHeight - startWorldScreenHeight
    };
    this.parent.emit("snap-zoom-start", this.parent);
  }
  resize() {
    this.snapping = null;
    if (this.options.width > 0) {
      this.xScale = this.parent.screenWidth / this.options.width;
    }
    if (this.options.height > 0) {
      this.yScale = this.parent.screenHeight / this.options.height;
    }
    this.xScale = this.xIndependent ? this.xScale : this.yScale;
    this.yScale = this.yIndependent ? this.yScale : this.xScale;
  }
  wheel() {
    if (this.options.removeOnInterrupt) {
      this.parent.plugins.remove("snap-zoom");
    }
    return false;
  }
  down() {
    if (this.options.removeOnInterrupt) {
      this.parent.plugins.remove("snap-zoom");
    } else if (this.options.interrupt) {
      this.snapping = null;
    }
    return false;
  }
  update(elapsed) {
    if (this.paused) {
      return;
    }
    if (this.options.interrupt && this.parent.input.count() !== 0) {
      return;
    }
    let oldCenter;
    if (!this.options.center && !this.options.noMove) {
      oldCenter = this.parent.center;
    }
    if (!this.snapping) {
      if (this.parent.scale.x !== this.xScale || this.parent.scale.y !== this.yScale) {
        this.createSnapping();
      }
    } else if (this.snapping) {
      const snapping = this.snapping;
      snapping.time += elapsed;
      if (snapping.time >= this.options.time) {
        this.parent.scale.set(this.xScale, this.yScale);
        if (this.options.removeOnComplete) {
          this.parent.plugins.remove("snap-zoom");
        }
        this.parent.emit("snap-zoom-end", this.parent);
        this.snapping = null;
      } else {
        const snapping2 = this.snapping;
        const worldScreenWidth = this.ease(snapping2.time, snapping2.startX, snapping2.deltaX, this.options.time);
        const worldScreenHeight = this.ease(snapping2.time, snapping2.startY, snapping2.deltaY, this.options.time);
        this.parent.scale.x = this.parent.screenWidth / worldScreenWidth;
        this.parent.scale.y = this.parent.screenHeight / worldScreenHeight;
      }
      const clamp = this.parent.plugins.get("clamp-zoom", true);
      if (clamp) {
        clamp.clamp();
      }
      if (!this.options.noMove) {
        if (!this.options.center) {
          this.parent.moveCenter(oldCenter);
        } else {
          this.parent.moveCenter(this.options.center);
        }
      }
    }
  }
  resume() {
    this.snapping = null;
    super.resume();
  }
};
var DEFAULT_WHEEL_OPTIONS = {
  percent: 0.1,
  smooth: false,
  interrupt: true,
  reverse: false,
  center: null,
  lineHeight: 20,
  axis: "all",
  keyToPress: null,
  trackpadPinch: false,
  wheelZoom: true
};
var Wheel = class extends Plugin {
  /** Flags whether the keys required to zoom are pressed currently. */
  /**
   * This is called by {@link Viewport.wheel}.
   */
  constructor(parent, options = {}) {
    super(parent);
    this.options = Object.assign({}, DEFAULT_WHEEL_OPTIONS, options);
    this.keyIsPressed = false;
    if (this.options.keyToPress) {
      this.handleKeyPresses(this.options.keyToPress);
    }
  }
  /**
   * Handles keypress events and set the keyIsPressed boolean accordingly
   *
   * @param {array} codes - key codes that can be used to trigger zoom event
   */
  handleKeyPresses(codes) {
    window.addEventListener("keydown", (e) => {
      if (codes.includes(e.code)) {
        this.keyIsPressed = true;
      }
    });
    window.addEventListener("keyup", (e) => {
      if (codes.includes(e.code)) {
        this.keyIsPressed = false;
      }
    });
  }
  checkKeyPress() {
    return !this.options.keyToPress || this.keyIsPressed;
  }
  down() {
    if (this.options.interrupt) {
      this.smoothing = null;
    }
    return false;
  }
  isAxisX() {
    return ["all", "x"].includes(this.options.axis);
  }
  isAxisY() {
    return ["all", "y"].includes(this.options.axis);
  }
  update() {
    if (this.smoothing) {
      const point = this.smoothingCenter;
      const change = this.smoothing;
      let oldPoint;
      if (!this.options.center) {
        oldPoint = this.parent.toLocal(point);
      }
      if (this.isAxisX()) {
        this.parent.scale.x += change.x;
      }
      if (this.isAxisY()) {
        this.parent.scale.y += change.y;
      }
      this.parent.emit("zoomed", { viewport: this.parent, type: "wheel" });
      const clamp = this.parent.plugins.get("clamp-zoom", true);
      if (clamp) {
        clamp.clamp();
      }
      if (this.options.center) {
        this.parent.moveCenter(this.options.center);
      } else {
        const newPoint = this.parent.toGlobal(oldPoint);
        this.parent.x += point.x - newPoint.x;
        this.parent.y += point.y - newPoint.y;
      }
      this.parent.emit("moved", { viewport: this.parent, type: "wheel" });
      this.smoothingCount++;
      if (this.smoothingCount >= this.options.smooth) {
        this.smoothing = null;
      }
    }
  }
  pinch(e) {
    if (this.paused) {
      return;
    }
    const point = this.parent.input.getPointerPosition(e);
    const step = -e.deltaY * (e.deltaMode ? this.options.lineHeight : 1) / 200;
    const change = Math.pow(2, (1 + this.options.percent) * step);
    let oldPoint;
    if (!this.options.center) {
      oldPoint = this.parent.toLocal(point);
    }
    if (this.isAxisX()) {
      this.parent.scale.x *= change;
    }
    if (this.isAxisY()) {
      this.parent.scale.y *= change;
    }
    this.parent.emit("zoomed", { viewport: this.parent, type: "wheel" });
    const clamp = this.parent.plugins.get("clamp-zoom", true);
    if (clamp) {
      clamp.clamp();
    }
    if (this.options.center) {
      this.parent.moveCenter(this.options.center);
    } else {
      const newPoint = this.parent.toGlobal(oldPoint);
      this.parent.x += point.x - newPoint.x;
      this.parent.y += point.y - newPoint.y;
    }
    this.parent.emit("moved", { viewport: this.parent, type: "wheel" });
    this.parent.emit(
      "wheel",
      { wheel: { dx: e.deltaX, dy: e.deltaY, dz: e.deltaZ }, event: e, viewport: this.parent }
    );
  }
  wheel(e) {
    if (this.paused) {
      return false;
    }
    if (!this.checkKeyPress()) {
      return false;
    }
    if (e.ctrlKey && this.options.trackpadPinch) {
      this.pinch(e);
    } else if (this.options.wheelZoom) {
      const point = this.parent.input.getPointerPosition(e);
      const sign = this.options.reverse ? -1 : 1;
      const step = sign * -e.deltaY * (e.deltaMode ? this.options.lineHeight : 1) / 500;
      const change = Math.pow(2, (1 + this.options.percent) * step);
      if (this.options.smooth) {
        const original = {
          x: this.smoothing ? this.smoothing.x * (this.options.smooth - this.smoothingCount) : 0,
          y: this.smoothing ? this.smoothing.y * (this.options.smooth - this.smoothingCount) : 0
        };
        this.smoothing = {
          x: ((this.parent.scale.x + original.x) * change - this.parent.scale.x) / this.options.smooth,
          y: ((this.parent.scale.y + original.y) * change - this.parent.scale.y) / this.options.smooth
        };
        this.smoothingCount = 0;
        this.smoothingCenter = point;
      } else {
        let oldPoint;
        if (!this.options.center) {
          oldPoint = this.parent.toLocal(point);
        }
        if (this.isAxisX()) {
          this.parent.scale.x *= change;
        }
        if (this.isAxisY()) {
          this.parent.scale.y *= change;
        }
        this.parent.emit("zoomed", { viewport: this.parent, type: "wheel" });
        const clamp = this.parent.plugins.get("clamp-zoom", true);
        if (clamp) {
          clamp.clamp();
        }
        if (this.options.center) {
          this.parent.moveCenter(this.options.center);
        } else {
          const newPoint = this.parent.toGlobal(oldPoint);
          this.parent.x += point.x - newPoint.x;
          this.parent.y += point.y - newPoint.y;
        }
      }
      this.parent.emit("moved", { viewport: this.parent, type: "wheel" });
      this.parent.emit(
        "wheel",
        { wheel: { dx: e.deltaX, dy: e.deltaY, dz: e.deltaZ }, event: e, viewport: this.parent }
      );
    }
    return !this.parent.options.passiveWheel;
  }
};
var InputManager = class {
  /** List of active touches on viewport */
  constructor(viewport) {
    this.viewport = viewport;
    this.touches = [];
    this.addListeners();
  }
  /** Add input listeners */
  addListeners() {
    this.viewport.interactive = true;
    if (!this.viewport.forceHitArea) {
      this.viewport.hitArea = new Rectangle(0, 0, this.viewport.worldWidth, this.viewport.worldHeight);
    }
    this.viewport.on("pointerdown", this.down, this);
    this.viewport.on("pointermove", this.move, this);
    this.viewport.on("pointerup", this.up, this);
    this.viewport.on("pointerupoutside", this.up, this);
    this.viewport.on("pointercancel", this.up, this);
    this.viewport.on("pointerout", this.up, this);
    this.wheelFunction = (e) => this.handleWheel(e);
    this.viewport.options.divWheel.addEventListener(
      "wheel",
      this.wheelFunction,
      { passive: this.viewport.options.passiveWheel }
    );
    this.isMouseDown = false;
  }
  /**
   * Removes all event listeners from viewport
   * (useful for cleanup of wheel when removing viewport)
   */
  destroy() {
    this.viewport.options.divWheel.removeEventListener("wheel", this.wheelFunction);
  }
  /**
   * handle down events for viewport
   *
   * @param {PIXI.InteractionEvent} event
   */
  down(event) {
    if (this.viewport.pause || !this.viewport.worldVisible) {
      return;
    }
    if (event.data.pointerType === "mouse") {
      this.isMouseDown = true;
    } else if (!this.get(event.data.pointerId)) {
      this.touches.push({ id: event.data.pointerId, last: null });
    }
    if (this.count() === 1) {
      this.last = event.data.global.clone();
      const decelerate = this.viewport.plugins.get("decelerate", true);
      const bounce = this.viewport.plugins.get("bounce", true);
      if ((!decelerate || !decelerate.isActive()) && (!bounce || !bounce.isActive())) {
        this.clickedAvailable = true;
      } else {
        this.clickedAvailable = false;
      }
    } else {
      this.clickedAvailable = false;
    }
    const stop = this.viewport.plugins.down(event);
    if (stop && this.viewport.options.stopPropagation) {
      event.stopPropagation();
    }
  }
  /** Clears all pointer events */
  clear() {
    this.isMouseDown = false;
    this.touches = [];
    this.last = null;
  }
  /**
   * @param {number} change
   * @returns whether change exceeds threshold
   */
  checkThreshold(change) {
    if (Math.abs(change) >= this.viewport.threshold) {
      return true;
    }
    return false;
  }
  /** Handle move events for viewport */
  move(event) {
    if (this.viewport.pause || !this.viewport.worldVisible) {
      return;
    }
    const stop = this.viewport.plugins.move(event);
    if (this.clickedAvailable && this.last) {
      const distX = event.data.global.x - this.last.x;
      const distY = event.data.global.y - this.last.y;
      if (this.checkThreshold(distX) || this.checkThreshold(distY)) {
        this.clickedAvailable = false;
      }
    }
    if (stop && this.viewport.options.stopPropagation) {
      event.stopPropagation();
    }
  }
  /** Handle up events for viewport */
  up(event) {
    if (this.viewport.pause || !this.viewport.worldVisible) {
      return;
    }
    if (event.data.pointerType === "mouse") {
      this.isMouseDown = false;
    }
    if (event.data.pointerType !== "mouse") {
      this.remove(event.data.pointerId);
    }
    const stop = this.viewport.plugins.up(event);
    if (this.clickedAvailable && this.count() === 0 && this.last) {
      this.viewport.emit("clicked", {
        event,
        screen: this.last,
        world: this.viewport.toWorld(this.last),
        viewport: this
      });
      this.clickedAvailable = false;
    }
    if (stop && this.viewport.options.stopPropagation) {
      event.stopPropagation();
    }
  }
  /** Gets pointer position if this.interaction is set */
  getPointerPosition(event) {
    const point = new Point();
    if (this.viewport.options.interaction) {
      this.viewport.options.interaction.mapPositionToPoint(point, event.clientX, event.clientY);
    } else if (this.viewport.options.useDivWheelForInputManager && this.viewport.options.divWheel) {
      const rect = this.viewport.options.divWheel.getBoundingClientRect();
      point.x = event.clientX - rect.left;
      point.y = event.clientY - rect.top;
    } else {
      point.x = event.clientX;
      point.y = event.clientY;
    }
    return point;
  }
  /** Handle wheel events */
  handleWheel(event) {
    if (this.viewport.pause || !this.viewport.worldVisible) {
      return;
    }
    if (this.viewport.options.interaction && this.viewport.options.interaction.interactionDOMElement !== event.target) {
      return;
    }
    const point = this.viewport.toLocal(this.getPointerPosition(event));
    if (this.viewport.left <= point.x && point.x <= this.viewport.right && this.viewport.top <= point.y && point.y <= this.viewport.bottom) {
      const stop = this.viewport.plugins.wheel(event);
      if (stop && !this.viewport.options.passiveWheel) {
        event.preventDefault();
      }
    }
  }
  pause() {
    this.touches = [];
    this.isMouseDown = false;
  }
  /** Get touch by id */
  get(id) {
    for (const touch of this.touches) {
      if (touch.id === id) {
        return touch;
      }
    }
    return null;
  }
  /** Remove touch by number */
  remove(id) {
    for (let i = 0; i < this.touches.length; i++) {
      if (this.touches[i].id === id) {
        this.touches.splice(i, 1);
        return;
      }
    }
  }
  /**
   * @returns {number} count of mouse/touch pointers that are down on the viewport
   */
  count() {
    return (this.isMouseDown ? 1 : 0) + this.touches.length;
  }
};
function _optionalChain(ops) {
  let lastAccessLHS = void 0;
  let value = ops[0];
  let i = 1;
  while (i < ops.length) {
    const op = ops[i];
    const fn = ops[i + 1];
    i += 2;
    if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
      return void 0;
    }
    if (op === "access" || op === "optionalAccess") {
      lastAccessLHS = value;
      value = fn(value);
    } else if (op === "call" || op === "optionalCall") {
      value = fn((...args) => value.call(lastAccessLHS, ...args));
      lastAccessLHS = void 0;
    }
  }
  return value;
}
var PLUGIN_ORDER = [
  "drag",
  "pinch",
  "wheel",
  "follow",
  "mouse-edges",
  "decelerate",
  "animate",
  "bounce",
  "snap-zoom",
  "clamp-zoom",
  "snap",
  "clamp"
];
var PluginManager = class {
  /** Maps mounted plugins by their type */
  /**
   * List of plugins mounted
   *
   * This list is kept sorted by the internal priority of plugins (hard-coded).
   */
  /** The viewport using the plugins managed by `this`. */
  /** This is called by {@link Viewport} to initialize the {@link Viewport.plugins plugins}. */
  constructor(viewport) {
    this.viewport = viewport;
    this.list = [];
    this.plugins = {};
  }
  /**
   * Inserts a named plugin or a user plugin into the viewport
   * default plugin order: 'drag', 'pinch', 'wheel', 'follow', 'mouse-edges', 'decelerate', 'bounce',
   * 'snap-zoom', 'clamp-zoom', 'snap', 'clamp'
   *
   * @param {string} name of plugin
   * @param {Plugin} plugin - instantiated Plugin class
   * @param {number} index to insert userPlugin (otherwise inserts it at the end)
   */
  add(name, plugin, index = PLUGIN_ORDER.length) {
    const oldPlugin = this.plugins[name];
    if (oldPlugin) {
      oldPlugin.destroy();
    }
    this.plugins[name] = plugin;
    const current = PLUGIN_ORDER.indexOf(name);
    if (current !== -1) {
      PLUGIN_ORDER.splice(current, 1);
    }
    PLUGIN_ORDER.splice(index, 0, name);
    this.sort();
  }
  /**
   * Get plugin
   *
   * @param {string} name of plugin
   * @param {boolean} [ignorePaused] return null if plugin is paused
   */
  get(name, ignorePaused) {
    if (ignorePaused) {
      if (_optionalChain([this, "access", (_) => _.plugins, "access", (_2) => _2[name], "optionalAccess", (_3) => _3.paused])) {
        return null;
      }
    }
    return this.plugins[name];
  }
  /**
   * Update all active plugins
   *
   * @internal
   * @ignore
   * @param {number} elapsed type in milliseconds since last update
   */
  update(elapsed) {
    for (const plugin of this.list) {
      plugin.update(elapsed);
    }
  }
  /**
   * Resize all active plugins
   *
   * @internal
   * @ignore
   */
  resize() {
    for (const plugin of this.list) {
      plugin.resize();
    }
  }
  /** Clamps and resets bounce and decelerate (as needed) after manually moving viewport */
  reset() {
    for (const plugin of this.list) {
      plugin.reset();
    }
  }
  /** removes all installed plugins */
  removeAll() {
    this.list.forEach((plugin) => {
      plugin.destroy();
    });
    this.plugins = {};
    this.sort();
  }
  /**
   * Removes installed plugin
   *
   * @param {string} name of plugin (e.g., 'drag', 'pinch')
   */
  remove(name) {
    if (this.plugins[name]) {
      _optionalChain([this, "access", (_4) => _4.plugins, "access", (_5) => _5[name], "optionalAccess", (_6) => _6.destroy, "call", (_7) => _7()]);
      delete this.plugins[name];
      this.viewport.emit(`${name}-remove`);
      this.sort();
    }
  }
  /**
   * Pause plugin
   *
   * @param {string} name of plugin (e.g., 'drag', 'pinch')
   */
  pause(name) {
    _optionalChain([this, "access", (_8) => _8.plugins, "access", (_9) => _9[name], "optionalAccess", (_10) => _10.pause, "call", (_11) => _11()]);
  }
  /**
   * Resume plugin
   *
   * @param {string} name of plugin (e.g., 'drag', 'pinch')
   */
  resume(name) {
    _optionalChain([this, "access", (_12) => _12.plugins, "access", (_13) => _13[name], "optionalAccess", (_14) => _14.resume, "call", (_15) => _15()]);
  }
  /**
   * Sort plugins according to PLUGIN_ORDER
   *
   * @internal
   * @ignore
   */
  sort() {
    this.list = [];
    for (const plugin of PLUGIN_ORDER) {
      if (this.plugins[plugin]) {
        this.list.push(this.plugins[plugin]);
      }
    }
  }
  /**
   * Handle down for all plugins
   *
   * @internal
   * @ignore
   */
  down(event) {
    let stop = false;
    for (const plugin of this.list) {
      if (plugin.down(event)) {
        stop = true;
      }
    }
    return stop;
  }
  /**
   * Handle move for all plugins
   *
   * @internal
   * @ignore
   */
  move(event) {
    let stop = false;
    for (const plugin of this.viewport.plugins.list) {
      if (plugin.move(event)) {
        stop = true;
      }
    }
    return stop;
  }
  /**
   * Handle up for all plugins
   *
   * @internal
   * @ignore
   */
  up(event) {
    let stop = false;
    for (const plugin of this.list) {
      if (plugin.up(event)) {
        stop = true;
      }
    }
    return stop;
  }
  /**
   * Handle wheel event for all plugins
   *
   * @internal
   * @ignore
   */
  wheel(e) {
    let result = false;
    for (const plugin of this.list) {
      if (plugin.wheel(e)) {
        result = true;
      }
    }
    return result;
  }
};
var DEFAULT_VIEWPORT_OPTIONS = {
  screenWidth: window.innerWidth,
  screenHeight: window.innerHeight,
  worldWidth: null,
  worldHeight: null,
  threshold: 5,
  passiveWheel: true,
  stopPropagation: false,
  forceHitArea: null,
  noTicker: false,
  interaction: null,
  disableOnContextMenu: false,
  ticker: Ticker.shared
};
var Viewport = class _Viewport extends Container {
  /** Flags whether the viewport is being panned */
  /** Number of pixels to move to trigger an input event (e.g., drag, pinch) or disable a clicked event */
  /** Use this to add user plugins or access existing plugins (e.g., to pause, resume, or remove them) */
  /** Flags whether the viewport zoom is being changed. */
  /** The options passed when creating this viewport, merged with the default values */
  __init() {
    this._disableOnContextMenu = (e) => e.preventDefault();
  }
  /**
   * @param {IViewportOptions} ViewportOptions
   * @param {number} [options.screenWidth=window.innerWidth]
   * @param {number} [options.screenHeight=window.innerHeight]
   * @param {number} [options.worldWidth=this.width]
   * @param {number} [options.worldHeight=this.height]
   * @param {number} [options.threshold=5] number of pixels to move to trigger an input event (e.g., drag, pinch)
   * or disable a clicked event
   * @param {boolean} [options.passiveWheel=true] whether the 'wheel' event is set to passive (note: if false,
   * e.preventDefault() will be called when wheel is used over the viewport)
   * @param {boolean} [options.stopPropagation=false] whether to stopPropagation of events that impact the viewport
   * (except wheel events, see options.passiveWheel)
   * @param {HitArea} [options.forceHitArea] change the default hitArea from world size to a new value
   * @param {boolean} [options.noTicker] set this if you want to manually call update() function on each frame
   * @param {PIXI.Ticker} [options.ticker=PIXI.Ticker.shared] use this PIXI.ticker for updates
   * @param {PIXI.InteractionManager} [options.interaction=null] InteractionManager, available from instantiated
   * WebGLRenderer/CanvasRenderer.plugins.interaction - used to calculate pointer position relative to canvas
   * location on screen
   * @param {HTMLElement} [options.divWheel=document.body] div to attach the wheel event
   * @param {boolean} [options.disableOnContextMenu] remove oncontextmenu=() => {} from the divWheel element
   */
  constructor(options = {}) {
    super();
    _Viewport.prototype.__init.call(this);
    this.options = Object.assign(
      {},
      { divWheel: document.body },
      DEFAULT_VIEWPORT_OPTIONS,
      options
    );
    this.screenWidth = this.options.screenWidth;
    this.screenHeight = this.options.screenHeight;
    this._worldWidth = this.options.worldWidth;
    this._worldHeight = this.options.worldHeight;
    this.forceHitArea = this.options.forceHitArea;
    this.threshold = this.options.threshold;
    this.options.divWheel = this.options.divWheel || document.body;
    if (this.options.disableOnContextMenu) {
      this.options.divWheel.addEventListener("contextmenu", this._disableOnContextMenu);
    }
    if (!this.options.noTicker) {
      this.tickerFunction = () => this.update(this.options.ticker.elapsedMS);
      this.options.ticker.add(this.tickerFunction);
    }
    this.input = new InputManager(this);
    this.plugins = new PluginManager(this);
  }
  /** Overrides PIXI.Container's destroy to also remove the 'wheel' and PIXI.Ticker listeners */
  destroy(options) {
    if (!this.options.noTicker && this.tickerFunction) {
      this.options.ticker.remove(this.tickerFunction);
    }
    if (this.options.disableOnContextMenu) {
      this.options.divWheel.removeEventListener("contextmenu", this._disableOnContextMenu);
    }
    this.input.destroy();
    super.destroy(options);
  }
  /**
   * Update viewport on each frame.
   *
   * By default, you do not need to call this unless you set `options.noTicker=true`.
   *
   * @param {number} elapsed time in milliseconds since last update
   */
  update(elapsed) {
    if (!this.pause) {
      this.plugins.update(elapsed);
      if (this.lastViewport) {
        if (this.lastViewport.x !== this.x || this.lastViewport.y !== this.y) {
          this.moving = true;
        } else if (this.moving) {
          this.emit("moved-end", this);
          this.moving = false;
        }
        if (this.lastViewport.scaleX !== this.scale.x || this.lastViewport.scaleY !== this.scale.y) {
          this.zooming = true;
        } else if (this.zooming) {
          this.emit("zoomed-end", this);
          this.zooming = false;
        }
      }
      if (!this.forceHitArea) {
        this._hitAreaDefault = new Rectangle(this.left, this.top, this.worldScreenWidth, this.worldScreenHeight);
        this.hitArea = this._hitAreaDefault;
      }
      this._dirty = this._dirty || !this.lastViewport || this.lastViewport.x !== this.x || this.lastViewport.y !== this.y || this.lastViewport.scaleX !== this.scale.x || this.lastViewport.scaleY !== this.scale.y;
      this.lastViewport = {
        x: this.x,
        y: this.y,
        scaleX: this.scale.x,
        scaleY: this.scale.y
      };
      this.emit("frame-end", this);
    }
  }
  /**
   * Use this to set screen and world sizes, needed for pinch/wheel/clamp/bounce.
   * @param {number} screenWidth=window.innerWidth
   * @param {number} screenHeight=window.innerHeight
   * @param {number} [worldWidth]
   * @param {number} [worldHeight]
   */
  resize(screenWidth = window.innerWidth, screenHeight = window.innerHeight, worldWidth, worldHeight) {
    this.screenWidth = screenWidth;
    this.screenHeight = screenHeight;
    if (typeof worldWidth !== "undefined") {
      this._worldWidth = worldWidth;
    }
    if (typeof worldHeight !== "undefined") {
      this._worldHeight = worldHeight;
    }
    this.plugins.resize();
    this.dirty = true;
  }
  /** World width, in pixels */
  get worldWidth() {
    if (this._worldWidth) {
      return this._worldWidth;
    }
    return this.width / this.scale.x;
  }
  set worldWidth(value) {
    this._worldWidth = value;
    this.plugins.resize();
  }
  /** World height, in pixels */
  get worldHeight() {
    if (this._worldHeight) {
      return this._worldHeight;
    }
    return this.height / this.scale.y;
  }
  set worldHeight(value) {
    this._worldHeight = value;
    this.plugins.resize();
  }
  /** Get visible world bounds of viewport */
  getVisibleBounds() {
    return new Rectangle(this.left, this.top, this.worldScreenWidth, this.worldScreenHeight);
  }
  /** Change coordinates from screen to world */
  /**
   * Changes coordinate from screen to world
   * @param {number|PIXI.Point} x
   * @param {number} y
   * @returns {PIXI.Point}
   */
  toWorld(x, y) {
    if (arguments.length === 2) {
      return this.toLocal(new Point(x, y));
    }
    return this.toLocal(x);
  }
  /** Change coordinates from world to screen */
  /**
   * Changes coordinate from world to screen
   * @param {number|PIXI.Point} x
   * @param {number} y
   * @returns {PIXI.Point}
   */
  toScreen(x, y) {
    if (arguments.length === 2) {
      return this.toGlobal(new Point(x, y));
    }
    return this.toGlobal(x);
  }
  /** Screen width in world coordinates */
  get worldScreenWidth() {
    return this.screenWidth / this.scale.x;
  }
  /** Screen height in world coordinates */
  get worldScreenHeight() {
    return this.screenHeight / this.scale.y;
  }
  /** World width in screen coordinates */
  get screenWorldWidth() {
    return this.worldWidth * this.scale.x;
  }
  /** World height in screen coordinates */
  get screenWorldHeight() {
    return this.worldHeight * this.scale.y;
  }
  /** Center of screen in world coordinates */
  get center() {
    return new Point(
      this.worldScreenWidth / 2 - this.x / this.scale.x,
      this.worldScreenHeight / 2 - this.y / this.scale.y
    );
  }
  set center(value) {
    this.moveCenter(value);
  }
  /**
   * Move center of viewport to (x, y)
   * @param {number|PIXI.Point} x
   * @param {number} [y]
   * @return {Viewport}
   */
  moveCenter(...args) {
    let x;
    let y;
    if (typeof args[0] === "number") {
      x = args[0];
      y = args[1];
    } else {
      x = args[0].x;
      y = args[0].y;
    }
    const newX = (this.worldScreenWidth / 2 - x) * this.scale.x;
    const newY = (this.worldScreenHeight / 2 - y) * this.scale.y;
    if (this.x !== newX || this.y !== newY) {
      this.position.set(newX, newY);
      this.plugins.reset();
      this.dirty = true;
    }
    return this;
  }
  /** Top-left corner of Viewport */
  get corner() {
    return new Point(-this.x / this.scale.x, -this.y / this.scale.y);
  }
  set corner(value) {
    this.moveCorner(value);
  }
  /** Move Viewport's top-left corner; also clamps and resets decelerate and bounce (as needed) */
  /**
   * MoveCorner
   * @param {number|PIXI.Point} x
   * @param {number} [y]
   * @returns {Viewport}
   */
  moveCorner(...args) {
    let x;
    let y;
    if (args.length === 1) {
      x = -args[0].x * this.scale.x;
      y = -args[0].y * this.scale.y;
    } else {
      x = -args[0] * this.scale.x;
      y = -args[1] * this.scale.y;
    }
    if (x !== this.x || y !== this.y) {
      this.position.set(x, y);
      this.plugins.reset();
      this.dirty = true;
    }
    return this;
  }
  /** Get how many world pixels fit in screen's width */
  get screenWidthInWorldPixels() {
    return this.screenWidth / this.scale.x;
  }
  /** Get how many world pixels fit on screen's height */
  get screenHeightInWorldPixels() {
    return this.screenHeight / this.scale.y;
  }
  /**
   * Find the scale value that fits a world width on the screen
   * does not change the viewport (use fit... to change)
   *
   * @param width - Width in world pixels
   * @return - scale
   */
  findFitWidth(width) {
    return this.screenWidth / width;
  }
  /**
   * Finds the scale value that fits a world height on the screens
   * does not change the viewport (use fit... to change)
   *
   * @param height - Height in world pixels
   * @return - scale
   */
  findFitHeight(height) {
    return this.screenHeight / height;
  }
  /**
   * Finds the scale value that fits the smaller of a world width and world height on the screen
   * does not change the viewport (use fit... to change)
   *
   * @param {number} width in world pixels
   * @param {number} height in world pixels
   * @returns {number} scale
   */
  findFit(width, height) {
    const scaleX = this.screenWidth / width;
    const scaleY = this.screenHeight / height;
    return Math.min(scaleX, scaleY);
  }
  /**
   * Finds the scale value that fits the larger of a world width and world height on the screen
   * does not change the viewport (use fit... to change)
   *
   * @param {number} width in world pixels
   * @param {number} height in world pixels
   * @returns {number} scale
   */
  findCover(width, height) {
    const scaleX = this.screenWidth / width;
    const scaleY = this.screenHeight / height;
    return Math.max(scaleX, scaleY);
  }
  /**
   * Change zoom so the width fits in the viewport
   *
   * @param width - width in world coordinates
   * @param center - maintain the same center
   * @param scaleY - whether to set scaleY=scaleX
   * @param noClamp - whether to disable clamp-zoom
   * @returns {Viewport} this
   */
  fitWidth(width = this.worldWidth, center, scaleY = true, noClamp) {
    let save;
    if (center) {
      save = this.center;
    }
    this.scale.x = this.screenWidth / width;
    if (scaleY) {
      this.scale.y = this.scale.x;
    }
    const clampZoom = this.plugins.get("clamp-zoom", true);
    if (!noClamp && clampZoom) {
      clampZoom.clamp();
    }
    if (center && save) {
      this.moveCenter(save);
    }
    return this;
  }
  /**
   * Change zoom so the height fits in the viewport
   *
   * @param {number} [height=this.worldHeight] in world coordinates
   * @param {boolean} [center] maintain the same center of the screen after zoom
   * @param {boolean} [scaleX=true] whether to set scaleX = scaleY
   * @param {boolean} [noClamp] whether to disable clamp-zoom
   * @returns {Viewport} this
   */
  fitHeight(height = this.worldHeight, center, scaleX = true, noClamp) {
    let save;
    if (center) {
      save = this.center;
    }
    this.scale.y = this.screenHeight / height;
    if (scaleX) {
      this.scale.x = this.scale.y;
    }
    const clampZoom = this.plugins.get("clamp-zoom", true);
    if (!noClamp && clampZoom) {
      clampZoom.clamp();
    }
    if (center && save) {
      this.moveCenter(save);
    }
    return this;
  }
  /**
   * Change zoom so it fits the entire world in the viewport
   *
   * @param {boolean} center maintain the same center of the screen after zoom
   * @returns {Viewport} this
   */
  fitWorld(center) {
    let save;
    if (center) {
      save = this.center;
    }
    this.scale.x = this.screenWidth / this.worldWidth;
    this.scale.y = this.screenHeight / this.worldHeight;
    if (this.scale.x < this.scale.y) {
      this.scale.y = this.scale.x;
    } else {
      this.scale.x = this.scale.y;
    }
    const clampZoom = this.plugins.get("clamp-zoom", true);
    if (clampZoom) {
      clampZoom.clamp();
    }
    if (center && save) {
      this.moveCenter(save);
    }
    return this;
  }
  /**
   * Change zoom so it fits the size or the entire world in the viewport
   *
   * @param {boolean} [center] maintain the same center of the screen after zoom
   * @param {number} [width=this.worldWidth] desired width
   * @param {number} [height=this.worldHeight] desired height
   * @returns {Viewport} this
   */
  fit(center, width = this.worldWidth, height = this.worldHeight) {
    let save;
    if (center) {
      save = this.center;
    }
    this.scale.x = this.screenWidth / width;
    this.scale.y = this.screenHeight / height;
    if (this.scale.x < this.scale.y) {
      this.scale.y = this.scale.x;
    } else {
      this.scale.x = this.scale.y;
    }
    const clampZoom = this.plugins.get("clamp-zoom", true);
    if (clampZoom) {
      clampZoom.clamp();
    }
    if (center && save) {
      this.moveCenter(save);
    }
    return this;
  }
  /**
   * Zoom viewport to specific value.
   *
   * @param {number} scale value (e.g., 1 would be 100%, 0.25 would be 25%)
   * @param {boolean} [center] maintain the same center of the screen after zoom
   * @return {Viewport} this
   */
  setZoom(scale, center) {
    let save;
    if (center) {
      save = this.center;
    }
    this.scale.set(scale);
    const clampZoom = this.plugins.get("clamp-zoom", true);
    if (clampZoom) {
      clampZoom.clamp();
    }
    if (center && save) {
      this.moveCenter(save);
    }
    return this;
  }
  /**
   * Zoom viewport by a certain percent (in both x and y direction).
   *
   * @param {number} percent change (e.g., 0.25 would increase a starting scale of 1.0 to 1.25)
   * @param {boolean} [center] maintain the same center of the screen after zoom
   * @return {Viewport} this
   */
  zoomPercent(percent, center) {
    return this.setZoom(this.scale.x + this.scale.x * percent, center);
  }
  /**
   * Zoom viewport by increasing/decreasing width by a certain number of pixels.
   *
   * @param {number} change in pixels
   * @param {boolean} [center] maintain the same center of the screen after zoom
   * @return {Viewport} this
   */
  zoom(change, center) {
    this.fitWidth(change + this.worldScreenWidth, center);
    return this;
  }
  /** Changes scale of viewport and maintains center of viewport */
  get scaled() {
    return this.scale.x;
  }
  set scaled(scale) {
    this.setZoom(scale, true);
  }
  /**
   * Returns zoom to the desired scale
   *
   * @param {ISnapZoomOptions} options
   * @param {number} [options.width=0] - the desired width to snap (to maintain aspect ratio, choose width or height)
   * @param {number} [options.height=0] - the desired height to snap (to maintain aspect ratio, choose width or height)
   * @param {number} [options.time=1000] - time for snapping in ms
   * @param {(string|function)} [options.ease=easeInOutSine] ease function or name (see http://easings.net/
   *   for supported names)
   * @param {PIXI.Point} [options.center] - place this point at center during zoom instead of center of the viewport
   * @param {boolean} [options.interrupt=true] - pause snapping with any user input on the viewport
   * @param {boolean} [options.removeOnComplete] - removes this plugin after snapping is complete
   * @param {boolean} [options.removeOnInterrupt] - removes this plugin if interrupted by any user input
   * @param {boolean} [options.forceStart] - starts the snap immediately regardless of whether the viewport is at the
   *   desired zoom
   * @param {boolean} [options.noMove] - zoom but do not move
   */
  snapZoom(options) {
    this.plugins.add("snap-zoom", new SnapZoom(this, options));
    return this;
  }
  /** Is container out of world bounds */
  OOB() {
    return {
      left: this.left < 0,
      right: this.right > this.worldWidth,
      top: this.top < 0,
      bottom: this.bottom > this.worldHeight,
      cornerPoint: new Point(
        this.worldWidth * this.scale.x - this.screenWidth,
        this.worldHeight * this.scale.y - this.screenHeight
      )
    };
  }
  /** World coordinates of the right edge of the screen */
  get right() {
    return -this.x / this.scale.x + this.worldScreenWidth;
  }
  set right(value) {
    this.x = -value * this.scale.x + this.screenWidth;
    this.plugins.reset();
  }
  /** World coordinates of the left edge of the screen */
  get left() {
    return -this.x / this.scale.x;
  }
  set left(value) {
    this.x = -value * this.scale.x;
    this.plugins.reset();
  }
  /** World coordinates of the top edge of the screen */
  get top() {
    return -this.y / this.scale.y;
  }
  set top(value) {
    this.y = -value * this.scale.y;
    this.plugins.reset();
  }
  /** World coordinates of the bottom edge of the screen */
  get bottom() {
    return -this.y / this.scale.y + this.worldScreenHeight;
  }
  set bottom(value) {
    this.y = -value * this.scale.y + this.screenHeight;
    this.plugins.reset();
  }
  /**
   * Determines whether the viewport is dirty (i.e., needs to be rendered to the screen because of a change)
   */
  get dirty() {
    return !!this._dirty;
  }
  set dirty(value) {
    this._dirty = value;
  }
  /**
   * Permanently changes the Viewport's hitArea
   *
   * NOTE: if not set then hitArea = PIXI.Rectangle(Viewport.left, Viewport.top, Viewport.worldScreenWidth,
   * Viewport.worldScreenHeight)
   */
  get forceHitArea() {
    return this._forceHitArea;
  }
  set forceHitArea(value) {
    if (value) {
      this._forceHitArea = value;
      this.hitArea = value;
    } else {
      this._forceHitArea = null;
      this.hitArea = new Rectangle(0, 0, this.worldWidth, this.worldHeight);
    }
  }
  /**
   * Enable one-finger touch to drag
   *
   * NOTE: if you expect users to use right-click dragging, you should enable `viewport.options.disableOnContextMenu`
   * to avoid the context menu popping up on each right-click drag.
   *
   * @param {IDragOptions} [options]
   * @param {string} [options.direction=all] direction to drag
   * @param {boolean} [options.pressDrag=true] whether click to drag is active
   * @param {boolean} [options.wheel=true] use wheel to scroll in direction (unless wheel plugin is active)
   * @param {number} [options.wheelScroll=1] number of pixels to scroll with each wheel spin
   * @param {boolean} [options.reverse] reverse the direction of the wheel scroll
   * @param {(boolean|string)} [options.clampWheel=false] clamp wheel(to avoid weird bounce with mouse wheel)
   * @param {string} [options.underflow=center] where to place world if too small for screen
   * @param {number} [options.factor=1] factor to multiply drag to increase the speed of movement
   * @param {string} [options.mouseButtons=all] changes which mouse buttons trigger drag, use: 'all', 'left',
   *  'right' 'middle', or some combination, like, 'middle-right'; you may want to set
   *   viewport.options.disableOnContextMenu if you want to use right-click dragging
   * @param {string[]} [options.keyToPress=null] - array containing
   *  {@link key|https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code} codes of keys that can be
   *  pressed for the drag to be triggered, e.g.: ['ShiftLeft', 'ShiftRight'}.
   * @param {boolean} [options.ignoreKeyToPressOnTouch=false] - ignore keyToPress for touch events
   * @param {number} [options.lineHeight=20] - scaling factor for non-DOM_DELTA_PIXEL scrolling events
   * @returns {Viewport} this
   */
  drag(options) {
    this.plugins.add("drag", new Drag(this, options));
    return this;
  }
  /**
   * Clamp to world boundaries or other provided boundaries
   * There are three ways to clamp:
   * 1. direction: 'all' = the world is clamped to its world boundaries, ie, you cannot drag any part of offscreen
   *    direction: 'x' | 'y' = only the x or y direction is clamped to its world boundary
   * 2. left, right, top, bottom = true | number = the world is clamped to the world's pixel location for each side;
   *    if any of these are set to true, then the location is set to the boundary
   *    [0, viewport.worldWidth/viewport.worldHeight], eg: to allow the world to be completely dragged offscreen,
   *    set [-viewport.worldWidth, -viewport.worldHeight, viewport.worldWidth * 2, viewport.worldHeight * 2]
   *
   * Underflow determines what happens when the world is smaller than the viewport
   * 1. none = the world is clamped but there is no special behavior
   * 2. center = the world is centered on the viewport
   * 3. combination of top/bottom/center and left/right/center (case insensitive) = the world is stuck to the
   *     appropriate boundaries
   *
   * NOTES:
   *   clamp is disabled if called with no options; use { direction: 'all' } for all edge clamping
   *   screenWidth, screenHeight, worldWidth, and worldHeight needs to be set for this to work properly
   *
   * @param {object} [options]
   * @param {(number|boolean)} [options.left=false] - clamp left; true = 0
   * @param {(number|boolean)} [options.right=false] - clamp right; true = viewport.worldWidth
   * @param {(number|boolean)} [options.top=false] - clamp top; true = 0
   * @param {(number|boolean)} [options.bottom=false] - clamp bottom; true = viewport.worldHeight
   * @param {string} [direction] - (all, x, or y) using clamps of [0, viewport.worldWidth/viewport.worldHeight];
   *  replaces left/right/top/bottom if set
   * @param {string} [underflow=center] - where to place world if too small for screen (e.g., top-right, center,
   *  none, bottomLeft)     * @returns {Viewport} this
   */
  clamp(options) {
    this.plugins.add("clamp", new Clamp(this, options));
    return this;
  }
  /**
   * Decelerate after a move
   *
   * NOTE: this fires 'moved' event during deceleration
   *
   * @param {IDecelerateOptions} [options]
   * @param {number} [options.friction=0.95] - percent to decelerate after movement
   * @param {number} [options.bounce=0.8] - percent to decelerate when past boundaries (only applicable when
   *   viewport.bounce() is active)
   * @param {number} [options.minSpeed=0.01] - minimum velocity before stopping/reversing acceleration
   * @return {Viewport} this
   */
  decelerate(options) {
    this.plugins.add("decelerate", new Decelerate(this, options));
    return this;
  }
  /**
   * Bounce on borders
   * NOTES:
   *    screenWidth, screenHeight, worldWidth, and worldHeight needs to be set for this to work properly
   *    fires 'moved', 'bounce-x-start', 'bounce-y-start', 'bounce-x-end', and 'bounce-y-end' events
   * @param {object} [options]
   * @param {string} [options.sides=all] - all, horizontal, vertical, or combination of top, bottom, right, left
   *  (e.g., 'top-bottom-right')
   * @param {number} [options.friction=0.5] - friction to apply to decelerate if active
   * @param {number} [options.time=150] - time in ms to finish bounce
   * @param {object} [options.bounceBox] - use this bounceBox instead of (0, 0, viewport.worldWidth, viewport.worldHeight)
   * @param {number} [options.bounceBox.x=0]
   * @param {number} [options.bounceBox.y=0]
   * @param {number} [options.bounceBox.width=viewport.worldWidth]
   * @param {number} [options.bounceBox.height=viewport.worldHeight]
   * @param {string|function} [options.ease=easeInOutSine] - ease function or name
   *  (see http://easings.net/ for supported names)
   * @param {string} [options.underflow=center] - (top/bottom/center and left/right/center, or center)
   *  where to place world if too small for screen
   * @return {Viewport} this
   */
  bounce(options) {
    this.plugins.add("bounce", new Bounce(this, options));
    return this;
  }
  /**
   * Enable pinch to zoom and two-finger touch to drag
   *
   * @param {PinchOptions} [options]
   * @param {boolean} [options.noDrag] - disable two-finger dragging
   * @param {number} [options.percent=1] - percent to modify pinch speed
   * @param {number} [options.factor=1] - factor to multiply two-finger drag to increase the speed of movement
   * @param {PIXI.Point} [options.center] - place this point at center during zoom instead of center of two fingers
   * @param {('all'|'x'|'y')} [options.axis=all] - axis to zoom
   * @return {Viewport} this
   */
  pinch(options) {
    this.plugins.add("pinch", new Pinch(this, options));
    return this;
  }
  /**
   * Snap to a point
   *
   * @param {number} x
   * @param {number} y
   * @param {ISnapOptions} [options]
   * @param {boolean} [options.topLeft] - snap to the top-left of viewport instead of center
   * @param {number} [options.friction=0.8] - friction/frame to apply if decelerate is active
   * @param {number} [options.time=1000] - time in ms to snap
   * @param {string|function} [options.ease=easeInOutSine] - ease function or name (see http://easings.net/
   *   for supported names)
   * @param {boolean} [options.interrupt=true] - pause snapping with any user input on the viewport
   * @param {boolean} [options.removeOnComplete] - removes this plugin after snapping is complete
   * @param {boolean} [options.removeOnInterrupt] - removes this plugin if interrupted by any user input
   * @param {boolean} [options.forceStart] - starts the snap immediately regardless of whether the viewport is at
   *   the desired location
   * @return {Viewport} this
   */
  snap(x, y, options) {
    this.plugins.add("snap", new Snap(this, x, y, options));
    return this;
  }
  /**
   * Follow a target
   *
   * NOTES:
   *    uses the (x, y) as the center to follow; for PIXI.Sprite to work properly, use sprite.anchor.set(0.5)
   *    options.acceleration is not perfect as it doesn't know the velocity of the target. It adds acceleration
   *    to the start of movement and deceleration to the end of movement when the target is stopped.
   *    To cancel the follow, use: `viewport.plugins.remove('follow')`
   *
   * @fires 'moved' event
   *
   * @param {PIXI.DisplayObject} target to follow
   * @param {IFollowOptions} [options]
   * @param {number} [options.speed=0] - to follow in pixels/frame (0=teleport to location)
   * @param {number} [options.acceleration] - set acceleration to accelerate and decelerate at this rate; speed
   *   cannot be 0 to use acceleration
   * @param {number} [options.radius] - radius (in world coordinates) of center circle where movement is allowed
   *   without moving the viewport     * @returns {Viewport} this
   * @returns {Viewport} this
   */
  follow(target, options) {
    this.plugins.add("follow", new Follow(this, target, options));
    return this;
  }
  /**
   * Zoom using mouse wheel
   *
   * NOTE: the default event listener for 'wheel' event is document.body. Use `Viewport.options.divWheel` to
   * change this default
   *
   * @param {IWheelOptions} [options]
   * @param {number} [options.percent=0.1] - percent to scroll with each spin
   * @param {number} [options.smooth] - smooth the zooming by providing the number of frames to zoom between wheel spins
   * @param {boolean} [options.interrupt=true] - stop smoothing with any user input on the viewport
   * @param {boolean} [options.reverse] - reverse the direction of the scroll
   * @param {PIXI.Point} [options.center] - place this point at center during zoom instead of current mouse position
   * @param {number} [options.lineHeight=20] - scaling factor for non-DOM_DELTA_PIXEL scrolling events
   * @param {('all'|'x'|'y')} [options.axis=all] - axis to zoom
   * @return {Viewport} this
   */
  wheel(options) {
    this.plugins.add("wheel", new Wheel(this, options));
    return this;
  }
  /**
   * Animate the position and/or scale of the viewport
   * To set the zoom level, use: (1) scale, (2) scaleX and scaleY, or (3) width and/or height
   * @param {object} options
   * @param {number} [options.time=1000] - time to animate
   * @param {PIXI.Point} [options.position=viewport.center] - position to move viewport
   * @param {number} [options.width] - desired viewport width in world pixels (use instead of scale;
   *  aspect ratio is maintained if height is not provided)
   * @param {number} [options.height] - desired viewport height in world pixels (use instead of scale;
   *  aspect ratio is maintained if width is not provided)
   * @param {number} [options.scale] - scale to change zoom (scale.x = scale.y)
   * @param {number} [options.scaleX] - independently change zoom in x-direction
   * @param {number} [options.scaleY] - independently change zoom in y-direction
   * @param {(function|string)} [options.ease=linear] - easing function to use
   * @param {function} [options.callbackOnComplete]
   * @param {boolean} [options.removeOnInterrupt] removes this plugin if interrupted by any user input
   * @returns {Viewport} this
   */
  animate(options) {
    this.plugins.add("animate", new Animate(this, options));
    return this;
  }
  /**
   * Enable clamping of zoom to constraints
   *
   * The minWidth/Height settings are how small the world can get (as it would appear on the screen)
   * before clamping. The maxWidth/maxHeight is how larger the world can scale (as it would appear on
   * the screen) before clamping.
   *
   * For example, if you have a world size of 1000 x 1000 and a screen size of 100 x 100, if you set
   * minWidth/Height = 100 then the world will not be able to zoom smaller than the screen size (ie,
   * zooming out so it appears smaller than the screen). Similarly, if you set maxWidth/Height = 100
   * the world will not be able to zoom larger than the screen size (ie, zooming in so it appears
   * larger than the screen).
   *
   * @param {object} [options]
   * @param {number} [options.minWidth] - minimum width
   * @param {number} [options.minHeight] - minimum height
   * @param {number} [options.maxWidth] - maximum width
   * @param {number} [options.maxHeight] - maximum height
   * @param {number} [options.minScale] - minimum scale
   * @param {number} [options.maxScale] - minimum scale
   * @return {Viewport} this
   */
  clampZoom(options) {
    this.plugins.add("clamp-zoom", new ClampZoom(this, options));
    return this;
  }
  /**
   * Scroll viewport when mouse hovers near one of the edges or radius-distance from center of screen.
   *
   * NOTES: fires 'moved' event; there's a known bug where the mouseEdges does not work properly with "windowed" viewports
   *
   * @param {IMouseEdgesOptions} [options]
   * @param {number} [options.radius] - distance from center of screen in screen pixels
   * @param {number} [options.distance] - distance from all sides in screen pixels
   * @param {number} [options.top] - alternatively, set top distance (leave unset for no top scroll)
   * @param {number} [options.bottom] - alternatively, set bottom distance (leave unset for no top scroll)
   * @param {number} [options.left] - alternatively, set left distance (leave unset for no top scroll)
   * @param {number} [options.right] - alternatively, set right distance (leave unset for no top scroll)
   * @param {number} [options.speed=8] - speed in pixels/frame to scroll viewport
   * @param {boolean} [options.reverse] - reverse direction of scroll
   * @param {boolean} [options.noDecelerate] - don't use decelerate plugin even if it's installed
   * @param {boolean} [options.linear] - if using radius, use linear movement (+/- 1, +/- 1) instead of angled
   *   movement (Math.cos(angle from center), Math.sin(angle from center))
   * @param {boolean} [options.allowButtons] allows plugin to continue working even when there's a mousedown event
   */
  mouseEdges(options) {
    this.plugins.add("mouse-edges", new MouseEdges(this, options));
    return this;
  }
  /** Pause viewport (including animation updates such as decelerate) */
  get pause() {
    return !!this._pause;
  }
  set pause(value) {
    this._pause = value;
    this.lastViewport = null;
    this.moving = false;
    this.zooming = false;
    if (value) {
      this.input.pause();
    }
  }
  /**
   * Move the viewport so the bounding box is visible
   *
   * @param x - left
   * @param y - top
   * @param width
   * @param height
   * @param resizeToFit - Resize the viewport so the box fits within the viewport
   */
  ensureVisible(x, y, width, height, resizeToFit) {
    if (resizeToFit && (width > this.worldScreenWidth || height > this.worldScreenHeight)) {
      this.fit(true, width, height);
      this.emit("zoomed", { viewport: this, type: "ensureVisible" });
    }
    let moved = false;
    if (x < this.left) {
      this.left = x;
      moved = true;
    } else if (x + width > this.right) {
      this.right = x + width;
      moved = true;
    }
    if (y < this.top) {
      this.top = y;
      moved = true;
    } else if (y + height > this.bottom) {
      this.bottom = y + height;
      moved = true;
    }
    if (moved) {
      this.emit("moved", { viewport: this, type: "ensureVisible" });
    }
  }
};
export {
  Animate,
  Bounce,
  Clamp,
  ClampZoom,
  Decelerate,
  Drag,
  Follow,
  InputManager,
  MouseEdges,
  Pinch,
  Plugin,
  PluginManager,
  Snap,
  SnapZoom,
  Viewport,
  Wheel
};
/*! Bundled license information:

@pixi/constants/dist/esm/constants.mjs:
  (*!
   * @pixi/constants - v6.5.10
   * Compiled Thu, 06 Jul 2023 15:25:11 UTC
   *
   * @pixi/constants is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)

@pixi/settings/dist/esm/settings.mjs:
  (*!
   * @pixi/settings - v6.5.10
   * Compiled Thu, 06 Jul 2023 15:25:11 UTC
   *
   * @pixi/settings is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)

@pixi/extensions/dist/esm/extensions.mjs:
  (*!
   * @pixi/extensions - v6.5.10
   * Compiled Thu, 06 Jul 2023 15:25:11 UTC
   *
   * @pixi/extensions is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

@pixi/ticker/dist/esm/ticker.mjs:
  (*!
   * @pixi/ticker - v6.5.10
   * Compiled Thu, 06 Jul 2023 15:25:11 UTC
   *
   * @pixi/ticker is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)

pixi-viewport/dist/esm/viewport.es.js:
  (*!
   * pixi-viewport - v5.1.0
   * Compiled Tue, 09 Apr 2024 15:05:21 UTC
   *
   * pixi-viewport is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   * 
   * Copyright 2019-2020, David Figatner, All Rights Reserved
   *)
*/
//# sourceMappingURL=pixi-viewport.js.map
